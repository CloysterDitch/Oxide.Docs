{
  "Hooks": [
    {
      "Type": 0,
      "Name": "OnTick",
      "HookName": "OnTick",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void DoTick()\r\n{\r\n\tInterface.CallHook(\"OnTick\");\r\n\tFacepunch.RCon.Update();\r\n\tCompanionServer.Server.Update();\r\n\tfor (int i = 0; i < Network.Net.sv.connections.Count; i++)\r\n\t{\r\n\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDisconnected",
      "HookName": "OnPlayerDisconnected",
      "HookParameters": {
        "BasePlayer": "basePlayer",
        "string": "strReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tPlatformService.Instance.EndPlayerSession(connection.userid);\r\n\tglobal::EACServer.OnLeaveGame(connection);\r\n\tglobal::BasePlayer basePlayer = connection.player as global::BasePlayer;\r\n\tif (basePlayer)\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDisconnected\", basePlayer, strReason);\r\n\t\tbasePlayer.OnDisconnected();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySpawned",
      "HookName": "OnEntitySpawned",
      "HookParameters": {
        "BaseNetworkable": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Spawn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.InitShared();\r\n\tthis.ServerInit();\r\n\tthis.PostInitShared();\r\n\tthis.UpdateNetworkGroup();\r\n\tthis.isSpawned = true;\r\n\tInterface.CallHook(\"OnEntitySpawned\", this);\r\n\tthis.SendNetworkUpdateImmediate(true);\r\n\tif (Rust.Application.isLoading && !Rust.Application.isLoadingSave)\r\n\t{\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this as global::BaseEntity);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "CodeLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "CodeLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "KeyLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "KeyLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "ItemCraftTask": "itemCraftTask",
        "BasePlayer": "owner",
        "Item": "fromTempBlueprint"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemCraft\", itemCraftTask, owner, fromTempBlueprint);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tthis.queue.AddLast(itemCraftTask);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntity",
      "HookName": "OnLootEntity",
      "HookParameters": {
        "PlayerLoot": "this",
        "BaseEntity": "targetEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tAssert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tthis.PositionChecks = doPositionChecks;\r\n\tthis.entitySource = targetEntity;\r\n\tthis.itemSource = null;\r\n\tInterface.CallHook(\"OnLootEntity\", this, targetEntity);\r\n\tthis.MarkDirty();\r\n\tglobal::ILootableEntity lootableEntity;\r\n\tif ((lootableEntity = (targetEntity as global::ILootableEntity)) != null)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootItem",
      "HookName": "OnLootItem",
      "HookParameters": {
        "PlayerLoot": "this",
        "Item": "item"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.PositionChecks = true;\r\n\tthis.containers.Add(item.contents);\r\n\titem.contents.onDirty += new System.Action(this.MarkDirty);\r\n\tthis.itemSource = item;\r\n\tthis.entitySource = item.GetWorldEntity();\r\n\tInterface.CallHook(\"OnLootItem\", this, item);\r\n\tthis.MarkDirty();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDeployed [Regular]",
      "HookName": "OnItemDeployed",
      "HookParameters": {
        "Deployer": "this",
        "ItemModDeployable": "ownerPlayer",
        "BaseEntity": "ownerPlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy_Regular",
        "ReturnType": "void",
        "Arguments": {
          "deployable": "Deployable",
          "ray": "UnityEngine.Ray"
        }
      },
      "CodeAfterInjection": "...\r\n\tbaseEntity.skinID = ownerItem.skin;\r\n\tbaseEntity.SendMessage(\"SetDeployedBy\", ownerPlayer, SendMessageOptions.DontRequireReceiver);\r\n\tbaseEntity.OwnerID = ownerPlayer.userID;\r\n\tbaseEntity.Spawn();\r\n\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\r\n\tInterface.CallHook(\"OnItemDeployed\", this, modDeployable, baseEntity);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\r\n\tbase.UseItemAmount(1);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBaseCombatEntityHurt",
      "HookName": "IOnBaseCombatEntityHurt",
      "HookParameters": {
        "BaseCombatEntity": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tinfo.damageTypes.Scale(Rust.DamageType.Bleeding, ConVar.Server.bleedingdamage);\r\n\t\tif (!(this is global::BasePlayer))\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(Rust.DamageType.Fun_Water, 0f);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"IOnBaseCombatEntityHurt\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.DebugHurt(info);\r\n\t\tthis.health = health - info.damageTypes.Total();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserGather",
      "HookName": "OnDispenserGather",
      "HookParameters": {
        "ResourceDispenser": "this",
        "BasePlayer": "entity",
        "Item": "num"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveResourceFromItem",
        "ReturnType": "void",
        "Arguments": {
          "entity": "BasePlayer",
          "itemAmt": "ItemAmount",
          "gatherDamage": "float",
          "destroyFraction": "float",
          "attackWeapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (num3 >= 1f)\r\n\t{\r\n\t\tint num6 = this.CalculateGatherBonus(entity, itemAmt, num3);\r\n\t\tint iAmount = Mathf.FloorToInt(num3) + num6;\r\n\t\tglobal::Item item = global::ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\r\n\t\tif (Interface.CallHook(\"OnDispenserGather\", this, entity, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (item == null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Melee]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "BaseMelee": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void DoAttackShared(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Projectile]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "playerProjectileAttack"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnProjectileAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (flag6)\r\n\t{\r\n\t\tthis.stats.Add(firedProjectile.itemMod.category + \"_hit_\" + hitEntity.Categorize(), 1, global::Stats.Steam);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this, hitInfo) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (firedProjectile.integrity <= 0f)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRunPlayerMetabolism",
      "HookName": "OnRunPlayerMetabolism",
      "HookParameters": {
        "PlayerMetabolism": "this",
        "BaseCombatEntity": "ownerEntity",
        "Single": "delta"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RunMetabolism",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "protected override void RunMetabolism(global::BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tif (Interface.CallHook(\"OnRunPlayerMetabolism\", this, ownerEntity, delta) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n\tfloat currentTemperature = this.owner.currentTemperature;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnUserApprove",
      "HookName": "IOnUserApprove",
      "HookParameters": {
        "Connection": "connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionAuth",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnNewConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::DeveloperList.Contains(connection.userid))\r\n\t{\r\n\t\tDebugEx.Log(connection.ToString() + \" is a developer\", StackTraceLogType.None);\r\n\t\tconnection.authLevel = 3u;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnUserApprove\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConnectionAuth.m_AuthConnection.Add(connection);\r\n\tbase.StartCoroutine(this.AuthorisationRoutine(connection));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [Signage]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "BasePlayer": "player",
        "Signage": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Signage",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [Signage]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "Signage": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [Signage]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "Signage": "this",
        "BasePlayer": "player",
        "int": "num"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tthis.textureIDs[num] = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player, num);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnLoseCondition",
      "HookName": "IOnLoseCondition",
      "HookParameters": {
        "Item": "this",
        "Single": "amount"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LoseCondition",
        "ReturnType": "void",
        "Arguments": {
          "amount": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ConVar.Debugging.disablecondition)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnLoseCondition\", this, amount) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat condition = this.condition;\r\n\tthis.condition -= amount;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnd",
      "HookName": "OnPlayerSleepEnd",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSleepEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Sleeping, false);\r\n\tthis.sleepStartTime = -1f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityGroundMissing",
      "HookName": "OnEntityGroundMissing",
      "HookParameters": {
        "BaseEntity": "baseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DestroyOnGroundMissing",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnGroundMissing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void OnGroundMissing()\r\n{\r\n\tglobal::BaseEntity baseEntity = base.gameObject.ToBaseEntity();\r\n\tif (baseEntity != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityGroundMissing\", baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseCombatEntity baseCombatEntity = baseEntity as global::BaseCombatEntity;\r\n\t\tif (baseCombatEntity != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorOpened",
      "HookName": "OnDoorOpened",
      "HookParameters": {
        "Door": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_OpenDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.checkPhysBoxesOnOpen)\r\n\t{\r\n\t\tthis.StartCheckingForBlockages(true);\r\n\t}\r\n\tInterface.CallHook(\"OnDoorOpened\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorClosed",
      "HookName": "OnDoorClosed",
      "HookParameters": {
        "Door": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_CloseDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.isSecurityDoor && this.NavMeshLink != null)\r\n\t{\r\n\t\tthis.SetNavMeshLinkEnabled(false);\r\n\t}\r\n\tthis.StartCheckingForBlockages(false);\r\n\tInterface.CallHook(\"OnDoorClosed\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerTick",
      "HookName": "OnPlayerTick",
      "HookParameters": {
        "BasePlayer": "this",
        "PlayerTick": "msg",
        "Boolean": "wasPlayerStalled"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceiveTick",
        "ReturnType": "void",
        "Arguments": {
          "msg": "PlayerTick",
          "wasPlayerStalled": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tthis.serverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerTick\", this, msg, wasPlayerStalled) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.serverInput.current.buttons != this.serverInput.previous.buttons)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerAttacked",
      "HookName": "IOnBasePlayerAttacked",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"IOnBasePlayerAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat health = base.health;\r\n\tif (this.InSafeZone() && !this.IsHostile() && info.Initiator != null && info.Initiator != this)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerHurt",
      "HookName": "IOnBasePlayerHurt",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsImmortalTo(info) && info.damageTypes.Total() >= 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnBasePlayerHurt\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (ConVar.Server.pve && info.Initiator && info.Initiator is global::BasePlayer && info.Initiator != this)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveThrown",
      "HookName": "OnExplosiveThrown",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseEntity": "vector",
        "ThrownWeapon": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoThrow",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * this.tumbleVelocity);\r\n\t}\r\n\tbaseEntity.Spawn();\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveThrown\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1);\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (player != null)\r\n\t{\r\n\t\tglobal::TimedExplosive timedExplosive = baseEntity as global::TimedExplosive;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeThrown",
      "HookName": "OnMeleeThrown",
      "HookParameters": {
        "BasePlayer": "player",
        "Item": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (projectileShoot != null)\r\n\t{\r\n\t\tprojectileShoot.Dispose();\r\n\t}\r\n\titem.SetParent(null);\r\n\tInterface.CallHook(\"OnMeleeThrown\", player, item);\r\n\tif (this.canAiHearIt)\r\n\t{\r\n\t\tfloat num = 0f;\r\n\t\tif (component.projectileObject != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHealingItemUse",
      "HookName": "OnHealingItemUse",
      "HookParameters": {
        "MedicalTool": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!component)\r\n\t{\r\n\t\tDebug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHealingItemUse\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanResearchItem",
      "HookName": "CanResearchItem",
      "HookParameters": {
        "BasePlayer": "player",
        "Item": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item targetItem = this.GetTargetItem();\r\n\tif (targetItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanResearchItem\", player, targetItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetItem.amount > 1)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemResearch",
      "HookName": "OnItemResearch",
      "HookParameters": {
        "ResearchTable": "this",
        "Item": "player",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item targetItem = this.GetTargetItem();\r\n\tif (targetItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanResearchItem\", player, targetItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetItem.amount > 1)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeWounded",
      "HookName": "CanBeWounded",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EligibleForWounding",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual bool EligibleForWounding(global::HitInfo info)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeWounded\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!ConVar.Server.woundingenabled)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRocketLaunched",
      "HookName": "OnRocketLaunched",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseEntity": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseLauncher",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SV_Launch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tcomponent2.InitializeVelocity(this.GetInheritedVelocity(player, vector2) + vector2 * component2.speed);\r\n\t}\r\n\tbaseEntity2.Spawn();\r\n\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity2, this);\r\n\tbase.StartAttackCooldown(base.ScaleRepeatDelay(this.repeatDelay));\r\n\tInterface.CallHook(\"OnRocketLaunched\", player, baseEntity2);\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponFired",
      "HookName": "OnWeaponFired",
      "HookParameters": {
        "BaseProjectile": "this",
        "BasePlayer": "player",
        "ItemModProjectile": "player",
        "ProjectileShoot": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(player, global::AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnWeaponFired\", this, msg.player, component, projectileShoot);\r\n\tif (player.InGesture)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SignalBroadcast(global::BaseEntity.Signal.Attack, string.Empty, msg.connection);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHammerHit",
      "HookName": "OnHammerHit",
      "HookParameters": {
        "BasePlayer": "ownerPlayer",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "Hammer",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tglobal::BaseCombatEntity baseCombatEntity = info.HitEntity as global::BaseCombatEntity;\r\n\tif (baseCombatEntity != null && ownerPlayer != null && base.isServer)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnHammerHit\", ownerPlayer, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\"DoRepair\", 50))\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSurveyGather",
      "HookName": "OnSurveyGather",
      "HookParameters": {
        "SurveyCharge": "this",
        "ItemManager": "itemManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCharge",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < num; i++)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item OxideGen_15 = global::ItemManager.Create(current.type, iAmount, 0uL);\r\n\t\t\t\tglobal::Item arg_1B3_0 = OxideGen_15;\r\n\t\t\t\tInterface.CallHook(\"OnSurveyGather\", this, OxideGen_15);\r\n\t\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up, true);\r\n\t\t\t\targ_1B3_0.Drop(base.transform.position + Vector3.up * 1f, this.GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAirdrop",
      "HookName": "OnAirdrop",
      "HookParameters": {
        "CargoPlane": "this",
        "Vector3": "newDropPosition"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateDropPosition",
        "ReturnType": "void",
        "Arguments": {
          "newDropPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.secondsToTake = Vector3.Distance(this.startPos, this.endPos) / 50f;\r\n\tthis.secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\r\n\tbase.transform.position = this.startPos;\r\n\tbase.transform.rotation = Quaternion.LookRotation(this.endPos - this.startPos);\r\n\tthis.dropPosition = newDropPosition;\r\n\tInterface.CallHook(\"OnAirdrop\", this, newDropPosition);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureRepair",
      "HookName": "OnStructureRepair",
      "HookParameters": {
        "BaseCombatEntity": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoRepair",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = player2;\r\n\tif (!this.repair.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureRepair\", this, player2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 30f;\r\n\tif (this.SecondsSinceAttacked <= num)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRepair",
      "HookName": "OnItemRepair",
      "HookParameters": {
        "BasePlayer": "player",
        "Item": "itemToRepair"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RepairAnItem",
        "ReturnType": "void",
        "Arguments": {
          "itemToRepair": "Item",
          "player": "BasePlayer",
          "repairBenchEntity": "BaseEntity",
          "maxConditionLostOnRepair": "float",
          "mustKnowBlueprint": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRepair\", player, itemToRepair) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = global::RepairBench.RepairCostFraction(itemToRepair);\r\n\tbool flag = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapSnapped",
      "HookName": "OnTrapSnapped",
      "HookParameters": {
        "BaseTrapTrigger": "this",
        "GameObject": "obj",
        "Collider": "col"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseTrapTrigger",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "OnObjectAdded",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject",
          "col": "UnityEngine.Collider"
        }
      },
      "CodeAfterInjection": "internal override void OnObjectAdded(GameObject obj, Collider col)\r\n{\r\n\tInterface.CallHook(\"OnTrapSnapped\", this, obj, col);\r\n\tbase.OnObjectAdded(obj, col);\r\n\tthis._trap.ObjectEntered(obj);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapDisarm",
      "HookName": "OnTrapDisarm",
      "HookParameters": {
        "Landmine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Disarm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapDisarm\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tif (UnityEngine.Random.Range(0, 100) < 15)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapArm",
      "HookName": "OnTrapArm",
      "HookParameters": {
        "BearTrap": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Arm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapArm\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Arm();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapImageUpdated",
      "HookName": "OnMapImageUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "MapEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ImageUpdate",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (b == 1)\r\n\t{\r\n\t\tthis.paintImages[(int)b2] = num3;\r\n\t}\r\n\tbase.InvalidateNetworkCache();\r\n\tInterface.CallHook(\"OnMapImageUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraftCancelled",
      "HookName": "OnItemCraftCancelled",
      "HookParameters": {
        "ItemCraftTask": "<>c__DisplayClass10_"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CancelTask",
        "ReturnType": "bool",
        "Arguments": {
          "iID": "int",
          "ReturnItems": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\titemCraftTask.cancelled = true;\r\n\tif (itemCraftTask.owner == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tInterface.CallHook(\"OnItemCraftCancelled\", itemCraftTask);\r\n\titemCraftTask.owner.Command(\"note.craft_done\", new object[]\r\n\t{\r\n\t\titemCraftTask.taskUID,\r\n\t\t0\r\n\t});\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResourceDepositCreated",
      "HookName": "OnResourceDepositCreated",
      "HookParameters": {
        "ResourceDeposit": "indexFrom"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceDepositManager",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "CreateFromPosition",
        "ReturnType": "ResourceDepositManager/ResourceDeposit",
        "Arguments": {
          "pos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tresourceDeposit.Add(global::ItemManager.FindItemDefinition(\"hq.metal.ore\"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), global::ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);\r\n\t\t}\r\n\t}\r\n\tthis._deposits.Add(indexFrom, resourceDeposit);\r\n\tInterface.CallHook(\"OnResourceDepositCreated\", resourceDeposit);\r\n\tUnityEngine.Random.state = arg_2D5_0;\r\n\treturn resourceDeposit;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "BaseNetworkable": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool ShouldNetworkTo(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.net.group == null || player.net.subscriber.IsSubscribed(this.net.group);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretTarget",
      "HookName": "OnTurretTarget",
      "HookParameters": {
        "AutoTurret": "this",
        "BaseCombatEntity": "targ"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "targ": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(global::BaseCombatEntity targ)\r\n{\r\n\tif (Interface.CallHook(\"OnTurretTarget\", this, targ) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targ != this.target)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [AutoTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "BaseCombatEntity": "obj",
        "AutoTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ObjectVisible",
        "ReturnType": "bool",
        "Arguments": {
          "obj": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool ObjectVisible(global::BaseCombatEntity obj)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", obj, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<RaycastHit> list = Pool.GetList<RaycastHit>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterTarget",
      "HookName": "OnHelicopterTarget",
      "HookParameters": {
        "HelicopterTurret": "this",
        "BaseCombatEntity": "newTarget"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "newTarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(global::BaseCombatEntity newTarget)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterTarget\", this, newTarget) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._target = newTarget;\r\n\tthis.UpdateTargetVisibility();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [HelicopterTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "BaseCombatEntity": "potentialtarget",
        "HelicopterTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "InFiringArc",
        "ReturnType": "bool",
        "Arguments": {
          "potentialtarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool InFiringArc(global::BaseCombatEntity potentialtarget)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", potentialtarget, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.AngleToTarget(potentialtarget) < 80f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBuild",
      "HookName": "CanBuild",
      "HookParameters": {
        "Planner": "this",
        "Construction": "ownerPlayer",
        "Target": "ownerPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "void",
        "Arguments": {
          "msg": "ProtoBuf.CreateBuilding"
        }
      },
      "CodeAfterInjection": "...\r\n\ttarget.position = msg.position;\r\n\ttarget.normal = msg.normal;\r\n\ttarget.rotation = msg.rotation;\r\n\ttarget.player = ownerPlayer;\r\n\ttarget.valid = true;\r\n\tif (Interface.CallHook(\"CanBuild\", this, construction, target) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (target.entity != null && deployable != null && deployable.setSocketParent)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEquipItem",
      "HookName": "CanEquipItem",
      "HookParameters": {
        "PlayerInventory": "this",
        "Item": "item",
        "Int32": "targetSlot"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanEquipItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanEquipItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEquipItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::ItemModContainerRestriction component = item.info.GetComponent<global::ItemModContainerRestriction>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWearItem",
      "HookName": "CanWearItem",
      "HookParameters": {
        "PlayerInventory": "this",
        "Item": "item",
        "Int32": "targetSlot"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanWearItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanWearItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWearItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.CanWearItem(item, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAcceptItem",
      "HookName": "CanAcceptItem",
      "HookParameters": {
        "ItemContainer": "this",
        "Item": "item",
        "Int32": "targetPos"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "ItemContainer/CanAcceptResult",
        "Arguments": {
          "item": "Item",
          "targetPos": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn global::ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAcceptItem\", this, item, targetPos);\r\n\tif (returnvar is global::ItemContainer.CanAcceptResult)\r\n\t{\r\n\t\treturn (global::ItemContainer.CanAcceptResult)returnvar;\r\n\t}\r\n\treturn global::ItemContainer.CanAcceptResult.CanAccept;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLootEnd",
      "HookName": "OnPlayerLootEnd",
      "HookParameters": {
        "PlayerLoot": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsLooting())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerLootEnd\", this);\r\n\tthis.MarkDirty();\r\n\tif (this.entitySource)\r\n\t{\r\n\t\tthis.entitySource.SendMessage(\"PlayerStoppedLooting\", base.baseEntity, SendMessageOptions.DontRequireReceiver);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSplit",
      "HookName": "OnItemSplit",
      "HookParameters": {
        "Item": "this",
        "Int32": "split_Amount"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SplitItem",
        "ReturnType": "Item",
        "Arguments": {
          "split_Amount": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (split_Amount >= this.amount)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemSplit\", this, split_Amount);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tthis.amount -= split_Amount;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [LootableCorpse]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "BasePlayer": "player",
        "LootableCorpse": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.ResetRemovalTime();\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [StorageContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "BasePlayer": "player",
        "StorageContainer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCreateWorldProjectile",
      "HookName": "CanCreateWorldProjectile",
      "HookParameters": {
        "HitInfo": "info",
        "ItemDefinition": "itemDef"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "protected virtual void CreateWorldProjectile(global::HitInfo info, global::ItemDefinition itemDef, global::ItemModProjectile itemMod, global::Projectile projectilePrefab, global::Item recycleItem)\r\n{\r\n\tif (Interface.CallHook(\"CanCreateWorldProjectile\", info, itemDef) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tglobal::Item item = (recycleItem != null) ? recycleItem : global::ItemManager.Create(itemDef, 1, 0uL);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPickup",
      "HookName": "OnItemPickup",
      "HookParameters": {
        "WorldItem": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "WorldItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Pickup",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.allowPickup)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemPickup\", this.item, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC(null, \"PickupSound\");\r\n\tglobal::Item item = this.item;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBypassQueue",
      "HookName": "CanBypassQueue",
      "HookParameters": {
        "Connection": "connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanJumpQueue",
        "ReturnType": "bool",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "private bool CanJumpQueue(Connection connection)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBypassQueue\", connection);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (global::DeveloperList.Contains(connection.userid))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityKill",
      "HookName": "OnEntityKill",
      "HookParameters": {
        "BaseNetworkable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Kill",
        "ReturnType": "void",
        "Arguments": {
          "mode": "BaseNetworkable/DestroyMode"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsDestroyed)\r\n\t{\r\n\t\tDebug.LogWarning(\"Calling kill - but already IsDestroyed!? \" + this);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityKill\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.gameObject.BroadcastOnParentDestroying();\r\n\tthis.DoEntityDestroy();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawned",
      "HookName": "OnPlayerRespawned",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RespawnAt",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "spawnPointEntity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net != null)\r\n\t{\r\n\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRespawned\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMessagePlayer",
      "HookName": "OnMessagePlayer",
      "HookParameters": {
        "string": "msg",
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ChatMessage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "string"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMessagePlayer\", msg, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendConsoleCommand(\"chat.add\", new object[]\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [exp]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "IPAddress": "Address"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (socket == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\tif (Interface.CallHook(\"OnRconConnection\", iPEndPoint.Address) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Facepunch.RCon.IsBanned(iPEndPoint.Address))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [exp, patch]",
      "HookName": "OnRconConnection [exp, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (socket == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\tif (Interface.CallHook(\"OnRconConnection\", iPEndPoint.Address) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Facepunch.RCon.IsBanned(iPEndPoint.Address))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientAuth",
      "HookName": "OnClientAuth",
      "HookParameters": {
        "Connection": "connection"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnGiveUserInformation",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n\tstring branch = ConVar.Server.branch;\r\n\tif (packet.read.Unread >= 4)\r\n\t{\r\n\t\ttext = packet.read.String(128);\r\n\t}\r\n\tInterface.CallHook(\"OnClientAuth\", packet.connection);\r\n\tif (branch != string.Empty && branch != text)\r\n\t{\r\n\t\tDebugEx.Log(string.Concat(new object[]\r\n\t\t{\r\n\t\t\t\"Kicking \",\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNewSave",
      "HookName": "OnNewSave",
      "HookParameters": {
        "string": "strFilename"
      },
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tstrFilename = global::World.SaveFolderName + \"/\" + global::World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnNewSave\", strFilename);\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn result;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerShutdown",
      "HookName": "IOnServerShutdown",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Shutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "internal void Shutdown()\r\n{\r\n\tInterface.CallHook(\"IOnServerShutdown\");\r\n\tglobal::BasePlayer[] array = global::BasePlayer.activePlayerList.ToArray<global::BasePlayer>();\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tarray[i].Kick(\"Server Shutting Down\");\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSaveLoad",
      "HookName": "OnSaveLoad",
      "HookParameters": {
        "Dictionary`2": "result"
      },
      "ReturnBehavior": 1,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tstrFilename = global::World.SaveFolderName + \"/\" + global::World.SaveFileName;\r\n\t\t}\r\n\t\tif (!System.IO.File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnNewSave\", strFilename);\r\n\t\t\tif (!System.IO.File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn result;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretStartup",
      "HookName": "OnTurretStartup",
      "HookParameters": {
        "AutoTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateStartup",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOnline() || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretStartup\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect.server.Run(this.onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tbase.Invoke(new System.Action(this.SetOnline), 2f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretShutdown",
      "HookName": "OnTurretShutdown",
      "HookParameters": {
        "AutoTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateShutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOffline() && !this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretShutdown\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new System.Action(this.SetOnline));\r\n\tthis.booting = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretToggle",
      "HookName": "OnTurretToggle",
      "HookParameters": {
        "AutoTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetIsOnline",
        "ReturnType": "void",
        "Arguments": {
          "online": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (online == base.HasFlag(global::BaseEntity.Flags.On))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretToggle\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, online, false, true);\r\n\tthis.booting = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleep",
      "HookName": "OnPlayerSleep",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerSleep\", this);\r\n\tif (this.InSafeZone() && !base.IsInvoking(new System.Action(this.ScheduledDeath)))\r\n\t{\r\n\t\tbase.Invoke(new System.Action(this.ScheduledDeath), global::NPCAutoTurret.sleeperhostiledelay);\r\n\t}\r\n\tglobal::BaseMountable baseMountable = this.GetMounted();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDeath",
      "HookName": "OnPlayerDeath",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\r\n\t\t\t\tthis.Belt.DropActive(this.GetDropPosition(), this.GetInheritedDropVelocity() + vector.normalized * 3f);\r\n\t\t\t}\r\n\t\t\tif (!this.WoundInsteadOfDying(info))\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnPlayerDeath\", this, info) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::SleepingBag.OnPlayerDeath(this);\r\n\t\t\t\tbase.Die(info);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRevive",
      "HookName": "OnPlayerRevive",
      "HookParameters": {
        "MedicalTool": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!component)\r\n\t{\r\n\t\tDebug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHealingItemUse\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenToggle",
      "HookName": "OnOvenToggle",
      "HookParameters": {
        "BaseOven": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprotected virtual void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnOvenToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag == base.IsOn())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [BearTrap]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "BearTrap": "this",
        "GameObject": "obj"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.hurtTarget = obj;\r\n\tbase.Invoke(new System.Action(this.DelayedFire), 0.05f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [Landmine]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "Landmine": "this",
        "GameObject": "obj"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tbase.CancelInvoke(new System.Action(this.Arm));\r\n\t\tthis.blocked = true;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer ply = obj.ToBaseEntity() as global::BasePlayer;\r\n\tthis.Trigger(ply);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainInitialized",
      "HookName": "OnTerrainInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "TerrainMeta",
      "Category": "World",
      "MethodData": {
        "MethodName": "PostSetupComponents",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::TerrainExtension[] components = base.GetComponents<global::TerrainExtension>();\r\n\tfor (int i = 0; i < components.Length; i++)\r\n\t{\r\n\t\tcomponents[i].PostSetup();\r\n\t}\r\n\tInterface.CallHook(\"OnTerrainInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [FlameTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "BasePlayer": "list",
        "FlameTurret": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (component.transform.position.y <= this.GetEyePosition().y + 0.5f && !component.IsBuildingAuthed())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindBurnable",
      "HookName": "OnFindBurnable",
      "HookParameters": {
        "BaseOven": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindBurnable",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public global::Item FindBurnable()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindBurnable\", this);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (base.inventory == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveDropped",
      "HookName": "OnExplosiveDropped",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseEntity": "vector",
        "ThrownWeapon": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoDrop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbaseEntity.creatorEntity = msg.player;\r\n\tbaseEntity.skinID = this.skinID;\r\n\tbaseEntity.Spawn();\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveDropped\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseVending",
      "HookName": "CanUseVending",
      "HookParameters": {
        "BasePlayer": "player",
        "VendingMachine": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanOpenLootPanel",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelName": "string"
        }
      },
      "CodeAfterInjection": "public override bool CanOpenLootPanel(global::BasePlayer player, string panelName)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn panelName == this.customerPanel || (base.CanOpenLootPanel(player, panelName) && this.CanPlayerAdmin(player));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "BasePlayer": "player",
        "VendingMachine": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanPlayerAdmin(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerBehind(player) && base.OccupiedCheck(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRefreshVendingStock",
      "HookName": "OnRefreshVendingStock",
      "HookParameters": {
        "VendingMachine": "this",
        "ItemDefinition": "itemDef"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RefreshSellOrderStockLevel",
        "ReturnType": "void",
        "Arguments": {
          "itemDef": "ItemDefinition"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\tSystem.Func<global::Item, int> arg_80_1;\r\n\t\t\t\tif ((arg_80_1 = global::VendingMachine.<>c.<>9__18_0) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\targ_80_1 = (global::VendingMachine.<>c.<>9__18_0 = new System.Func<global::Item, int>(global::VendingMachine.<>c.<>9.<RefreshSellOrderStockLevel>b__18_0));\r\n\t\t\t\t}\r\n\t\t\t\tInterface.CallHook(\"OnRefreshVendingStock\", this, itemDef);\r\n\t\t\t\targ_8C_1 = arg_80_0.Sum(arg_80_1) / current.itemToSellAmount;\r\n\t\t\t}\r\n\t\t\targ_8C_0.inStock = arg_8C_1;\r\n\t\t\tfloat itemCondition = 0f;\r\n\t\t\tfloat itemConditionMax = 0f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnToggleVendingBroadcast",
      "HookName": "OnToggleVendingBroadcast",
      "HookParameters": {
        "VendingMachine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_Broadcast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tbool b = msg.read.Bit();\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved4, b, false, true);\r\n\t\tInterface.CallHook(\"OnToggleVendingBroadcast\", this, player);\r\n\t\tthis.UpdateMapMarker();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDeleteVendingOffer",
      "HookName": "OnDeleteVendingOffer",
      "HookParameters": {
        "VendingMachine": "this",
        "int": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_DeleteSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.CanPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tInterface.CallHook(\"OnDeleteVendingOffer\", this, num);\r\n\tif (num >= 0 && num < this.sellOrders.sellOrders.Count)\r\n\t{\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[num];\r\n\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, false);\r\n\t\tthis.sellOrders.sellOrders.RemoveAt(num);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOpenVendingAdmin",
      "HookName": "OnOpenVendingAdmin",
      "HookParameters": {
        "VendingMachine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenAdmin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(player);\r\n\tthis.PlayerOpenLoot(player, \"\", true);\r\n\tbase.ClientRPCPlayer(null, player, \"CLIENT_OpenAdminMenu\");\r\n\tInterface.CallHook(\"OnOpenVendingAdmin\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [VendingMachine]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "VendingMachine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.OccupiedCheck(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(msg.player);\r\n\tthis.PlayerOpenLoot(msg.player, this.customerPanel, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRotateVendingMachine",
      "HookName": "OnRotateVendingMachine",
      "HookParameters": {
        "VendingMachine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_RotateVM",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RotateVM(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnRotateVendingMachine\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanRotate())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupEntity",
      "HookName": "CanPickupEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseCombatEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanPickup",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanPickup(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanPickupEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.pickup.enabled && (!this.pickup.requireBuildingPrivilege || player.CanBuild()) && (!this.pickup.requireHammer || player.IsHoldingEntity<global::Hammer>());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerSave",
      "HookName": "OnServerSave",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoAutomatedSave",
        "ReturnType": "System.Collections.IEnumerator",
        "Arguments": {
          "AndWait": "bool"
        }
      },
      "CodeAfterInjection": "[System.Runtime.CompilerServices.IteratorStateMachine(typeof(global::SaveRestore.<DoAutomatedSave>d__19))]\r\nprivate System.Collections.IEnumerator DoAutomatedSave(bool AndWait = false)\r\n{\r\n\tInterface.CallHook(\"OnServerSave\");\r\n\tglobal::SaveRestore.<DoAutomatedSave>d__19 expr_11 = new global::SaveRestore.<DoAutomatedSave>d__19(0);\r\n\texpr_11.<>4__this = this;\r\n\texpr_11.AndWait = AndWait;\r\n\treturn expr_11;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemAction",
      "HookName": "OnItemAction",
      "HookParameters": {
        "Item": "id",
        "string": "id",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ItemCmd",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.FindItemUID(id);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemAction\", item, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item.IsLocked() || (item.parent != null && item.parent.IsLocked()))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignBed",
      "HookName": "CanAssignBed",
      "HookParameters": {
        "BasePlayer": "player",
        "SleepingBag": "this",
        "ulong": "num"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanAssignBed\", msg.player, this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n\tif (activeGameMode != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCodeEntered",
      "HookName": "OnCodeEntered",
      "HookParameters": {
        "CodeLock": "this",
        "BasePlayer": "player",
        "string": "text"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UnlockWithCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String(256);\r\n\tif (Interface.CallHook(\"OnCodeEntered\", this, rpc.player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = text == this.guestCode;\r\n\tbool flag2 = text == this.code;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [CodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "BasePlayer": "player",
        "CodeLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryUnlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [code]",
      "HookName": "CanLock",
      "HookParameters": {
        "BasePlayer": "player",
        "CodeLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.code.Length != 4)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.whitelistPlayers.Contains(rpc.player.userID))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanChangeCode",
      "HookName": "CanChangeCode",
      "HookParameters": {
        "BasePlayer": "player",
        "CodeLock": "this",
        "string": "text",
        "bool": "text"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_ChangeCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.hasCode & flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanChangeCode\", rpc.player, this, text, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.hasCode && !flag)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [KeyLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "BasePlayer": "player",
        "KeyLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Unlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(rpc.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRecyclerToggle",
      "HookName": "OnRecyclerToggle",
      "HookParameters": {
        "Recycler": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (msg.player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRecyclerToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag && !this.HasRecyclable())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRecycle",
      "HookName": "CanRecycle",
      "HookParameters": {
        "Recycler": "this",
        "Item": "i"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "HasRecyclable",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tobject returnvar = Interface.CallHook(\"CanRecycle\", this, slot);\r\n\t\t\tif (returnvar is bool)\r\n\t\t\t{\r\n\t\t\t\treturn (bool)returnvar;\r\n\t\t\t}\r\n\t\t\tif (slot.info.Blueprint != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRecycle",
      "HookName": "OnItemRecycle",
      "HookParameters": {
        "Item": "flag",
        "Recycler": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretDeauthorize",
      "HookName": "OnTurretDeauthorize",
      "HookParameters": {
        "AutoTurret": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseEntity.RPCMessage rpc = rpc2;\r\n\tif (this.booting || this.IsOnline() || !this.IsAuthed(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tglobal::BasePlayer arg_A9_1 = rpc.player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSetBedPublic",
      "HookName": "CanSetBedPublic",
      "HookParameters": {
        "BasePlayer": "player",
        "SleepingBag": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_MakePublic",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsPublic())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanSetBedPublic\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPublic(flag);\r\n\tif (!this.IsPublic())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [ItemCrafter]",
      "HookName": "CanCraft",
      "HookParameters": {
        "ItemCrafter": "this",
        "ItemBlueprint": "bp",
        "Int32": "amount",
        "Boolean": "free"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "amount": "int",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (amount < 1 || amount > bp.targetItem.craftingStackable)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, bp, amount, free);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tforeach (global::ItemAmount current2 in bp.ingredients)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafeTarget",
      "HookName": "CanHelicopterStrafeTarget",
      "HookParameters": {
        "PatrolHelicopterAI": "this",
        "BasePlayer": "ply"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "ValidStrafeTarget",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool ValidStrafeTarget(global::BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafeTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !ply.IsNearEnemyBase();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDropped",
      "HookName": "OnItemDropped",
      "HookParameters": {
        "Item": "this",
        "BaseEntity": "baseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Drop",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "vPos": "UnityEngine.Vector3",
          "vVelocity": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.Remove(0f);\r\n\t}\r\n\tInterface.CallHook(\"OnItemDropped\", this, baseEntity);\r\n\tthis.RemoveFromContainer();\r\n\treturn baseEntity;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHideStash",
      "HookName": "CanHideStash",
      "HookParameters": {
        "BasePlayer": "player",
        "StashContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"CanHideStash\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemRecycle [2]",
      "HookName": "OnItemRecycle",
      "ReturnBehavior": 0,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnContainerDropItems",
      "HookName": "OnContainerDropItems",
      "HookParameters": {
        "ItemContainer": "container"
      },
      "ReturnBehavior": 1,
      "TargetType": "DropUtil",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DropItems",
        "ReturnType": "void",
        "Arguments": {
          "container": "ItemContainer",
          "position": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (container.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnContainerDropItems\", container) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0.25f;\r\n\tglobal::Item[] array = container.itemList.ToArray();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNpcEat [BaseNpc]",
      "HookName": "CanNpcEat",
      "HookParameters": {
        "BaseNpc": "this",
        "BaseEntity": "best"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "WantsToEat",
        "ReturnType": "bool",
        "Arguments": {
          "best": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool WantsToEat(global::BaseEntity best)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNpcEat\", this, best);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn best.HasTrait(global::BaseEntity.TraitFlag.Food) && !best.HasTrait(global::BaseEntity.TraitFlag.Alive);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeAttack",
      "HookName": "OnMeleeAttack",
      "HookParameters": {
        "BasePlayer": "player",
        "HitInfo": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\thitInfo.Initiator = player;\r\n\t\t\t\thitInfo.Weapon = this;\r\n\t\t\t\thitInfo.WeaponPrefab = this;\r\n\t\t\t\thitInfo.Predicted = msg.connection;\r\n\t\t\t\thitInfo.damageProperties = this.damageProperties;\r\n\t\t\t\tif (Interface.CallHook(\"OnMeleeAttack\", player, hitInfo) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (hitInfo.IsNaNOrInfinity())\r\n\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerViolation",
      "HookName": "OnPlayerViolation",
      "HookParameters": {
        "BasePlayer": "ply",
        "AntiHackType": "type",
        "Single": "amount"
      },
      "ReturnBehavior": 1,
      "TargetType": "AntiHack",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AddViolation",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer",
          "type": "AntiHackType",
          "amount": "float"
        }
      },
      "CodeAfterInjection": "public static void AddViolation(global::BasePlayer ply, global::AntiHackType type, float amount)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerViolation\", ply, type, amount) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"AntiHack.AddViolation\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseMailbox",
      "HookName": "CanUseMailbox",
      "HookParameters": {
        "BasePlayer": "player",
        "Mailbox": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerIsOwner",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerIsOwner(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseMailbox\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.CanBuild();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSpinWheel",
      "HookName": "OnSpinWheel",
      "HookParameters": {
        "BasePlayer": "player",
        "SpinnerWheel": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "SpinnerWheel",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Spin",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.AnyoneSpin() || rpc.player.CanBuild())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSpinWheel\", rpc.player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.velocity > 15f)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [GunTrap]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "BasePlayer": "list",
        "GunTrap": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!component.IsBuildingAuthed())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnRconInitialize",
      "HookName": "IOnRconInitialize",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"IOnRconInitialize\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (RCon.Port == 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMaxStackable",
      "HookName": "OnMaxStackable",
      "HookParameters": {
        "Item": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MaxStackable",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint num = this.info.stackable;\r\n\tif (this.parent != null && this.parent.maxStackSize > 0)\r\n\t{\r\n\t\tnum = Mathf.Min(this.parent.maxStackSize, num);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnMaxStackable\", this);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponReload",
      "HookName": "OnWeaponReload",
      "HookParameters": {
        "BaseProjectile": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartReload",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\t\tthis.reloadStarted = false;\r\n\t\tthis.reloadFinished = false;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWeaponReload\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.reloadFinished = false;\r\n\tthis.reloadStarted = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMagazineReload",
      "HookName": "OnMagazineReload",
      "HookParameters": {
        "BaseProjectile": "this",
        "int": "desiredAmount",
        "BasePlayer": "ownerPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "ReloadMagazine",
        "ReturnType": "void",
        "Arguments": {
          "desiredAmount": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMagazineReload\", this, desiredAmount, ownerPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.primaryMagazine.Reload(ownerPlayer, desiredAmount, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupLock",
      "HookName": "CanPickupLock",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_TakeLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanPickupLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = global::ItemManager.Create(this.itemType, 1, this.skinID);\r\n\tif (item != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanVendingAcceptItem",
      "HookName": "CanVendingAcceptItem",
      "HookParameters": {
        "VendingMachine": "this",
        "Item": "item",
        "Int32": "targetSlot"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "public bool CanAcceptItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanVendingAcceptItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BasePlayer ownerPlayer = item.GetOwnerPlayer();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiftUse",
      "HookName": "OnLiftUse",
      "HookParameters": {
        "Lift": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Lift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.MoveUp();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerUserRemove",
      "HookName": "OnServerUserRemove",
      "HookParameters": {
        "UInt64": "uid"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerUsers",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "uid": "ulong"
        }
      },
      "CodeAfterInjection": "public static void Remove(ulong uid)\r\n{\r\n\tInterface.CallHook(\"OnServerUserRemove\", uid);\r\n\tglobal::ServerUsers.users.Remove(uid);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "BasePlayer": "this",
        "String": "reason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Kick",
        "ReturnType": "void",
        "Arguments": {
          "reason": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.IsConnected)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNet.sv.Kick(this.net.connection, reason, false);\r\n\tInterface.CallHook(\"OnPlayerKicked\", this, reason);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBradleyApcTarget",
      "HookName": "CanBradleyApcTarget",
      "HookParameters": {
        "BradleyAPC": "this",
        "BaseEntity": "ent"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "VisibilityTest",
        "ReturnType": "bool",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\telse\r\n\t{\r\n\t\tDebug.LogWarning(\"Standard vis test!\");\r\n\t\tflag = base.IsVisible(ent.CenterPoint(), float.PositiveInfinity);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanBradleyApcTarget\", this, ent);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn flag;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcInitialize",
      "HookName": "OnBradleyApcInitialize",
      "HookParameters": {
        "BradleyAPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcInitialize\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.myRigidBody.centerOfMass = this.centerOfMass.localPosition;\r\n\tthis.destination = base.transform.position;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcHunt",
      "HookName": "OnBradleyApcHunt",
      "HookParameters": {
        "BradleyAPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Hunt",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateMovement_Hunt()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcHunt\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.patrolPath == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcPatrol",
      "HookName": "OnBradleyApcPatrol",
      "HookParameters": {
        "BradleyAPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Patrol",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.nextPatrolTime = Time.time + 20f;\r\n\tif (this.HasPath() && !this.IsAtFinalDestination())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBradleyApcPatrol\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IAIPathInterestNode randomInterestNodeAwayFrom = this.patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position, 10f);\r\n\tglobal::IAIPathNode closestToPoint = this.patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCompleteTrade",
      "HookName": "OnShopCompleteTrade",
      "HookParameters": {
        "ShopFront": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CompleteTrade",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void CompleteTrade()\r\n{\r\n\tif (this.vendorPlayer != null && this.customerPlayer != null && base.HasFlag(global::BaseEntity.Flags.Reserved1) && base.HasFlag(global::BaseEntity.Flags.Reserved2))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnShopCompleteTrade\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterUseNapalm",
      "HookName": "CanHelicopterUseNapalm",
      "HookParameters": {
        "PatrolHelicopterAI": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanUseNapalm",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanUseNapalm()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterUseNapalm\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastNapalmTime >= 30f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafe",
      "HookName": "CanHelicopterStrafe",
      "HookParameters": {
        "PatrolHelicopterAI": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanStrafe",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanStrafe()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafe\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastStrafeTime >= 20f && this.CanInterruptState();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterTarget",
      "HookName": "CanHelicopterTarget",
      "HookParameters": {
        "PatrolHelicopterAI": "this",
        "BasePlayer": "ply"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerVisible",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool PlayerVisible(global::BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tVector3 position = ply.eyes.position;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDismountEntity",
      "HookName": "CanDismountEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted",
      "HookName": "OnEntityDismounted",
      "HookParameters": {
        "BaseMountable": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted [lite]",
      "HookName": "OnEntityDismounted",
      "HookParameters": {
        "BaseMountable": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanMountEntity",
      "HookName": "CanMountEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.mountAnchor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.EnsureDismounted();\r\n\tthis._mounted = player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMounted",
      "HookName": "OnEntityMounted",
      "HookParameters": {
        "BaseMountable": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.mountAnchor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.EnsureDismounted();\r\n\tthis._mounted = player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [PlayerBlueprints]",
      "HookName": "CanCraft",
      "HookParameters": {
        "PlayerBlueprints": "this",
        "ItemDefinition": "itemDefinition",
        "int": "skinItemId"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBlueprints",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "itemid": "int",
          "skinItemId": "int",
          "playerId": "ulong"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::ItemDefinition itemDefinition = global::ItemManager.FindItemDefinition(itemid);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, itemDefinition, skinItemId);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (skinItemId == 0 || base.baseEntity.UnlockAllSkins || this.CheckSkinOwnership(skinItemId, playerId)) && base.baseEntity.currentCraftLevel >= (float)itemDefinition.Blueprint.workbenchLevelRequired && this.HasUnlocked(itemDefinition);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [Item]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "Item": "item",
        "ResearchTable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "public int ScrapForResearch(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", item, this);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn this.ScrapForResearch(item.info);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootSpawn [LootContainer]",
      "HookName": "OnLootSpawn",
      "HookParameters": {
        "LootContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootContainer",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\");\r\n\t\treturn;\r\n\t}\r\n\tbase.inventory.Clear();\r\n\tglobal::ItemManager.DoRemoves();\r\n\tif (Interface.CallHook(\"OnLootSpawn\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PopulateLoot();\r\n\tif (this.shouldRefreshContents)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDropActiveItem",
      "HookName": "CanDropActiveItem",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ShouldDropActiveItem",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool ShouldDropActiveItem()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDropActiveItem\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDropActiveItem",
      "HookName": "OnPlayerDropActiveItem",
      "HookParameters": {
        "PlayerBelt": "this",
        "Item": "activeItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBelt",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DropActive",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item activeItem = this.player.GetActiveItem();\r\n\tif (activeItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDropActiveItem\", this.player, activeItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerBelt.DropActive\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretClearList",
      "HookName": "OnTurretClearList",
      "HookParameters": {
        "AutoTurret": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.booting || this.IsOnline() || !this.IsAuthed(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tglobal::BasePlayer arg_80_1 = rpc.player;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretModeToggle",
      "HookName": "OnTurretModeToggle",
      "HookParameters": {
        "AutoTurret": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetPeacekeepermode",
        "ReturnType": "void",
        "Arguments": {
          "isOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, isOn, false, true);\r\n\tglobal::Effect.server.Run(this.peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tInterface.CallHook(\"OnTurretModeToggle\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldProjectileCreate",
      "HookName": "OnWorldProjectileCreate",
      "HookParameters": {
        "HitInfo": "info",
        "Item": "projectileVelocity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "protected virtual void CreateWorldProjectile(global::HitInfo info, global::ItemDefinition itemDef, global::ItemModProjectile itemMod, global::Projectile projectilePrefab, global::Item recycleItem)\r\n{\r\n\tif (Interface.CallHook(\"CanCreateWorldProjectile\", info, itemDef) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tglobal::Item item = (recycleItem != null) ? recycleItem : global::ItemManager.Create(itemDef, 1, 0uL);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveItemChange",
      "HookName": "OnActiveItemChange",
      "HookParameters": {
        "BasePlayer": "this",
        "Item": "item",
        "ItemId": "itemID"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateActiveItem",
        "ReturnType": "void",
        "Arguments": {
          "itemID": "ItemId"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tglobal::Item activeItem = this.GetActiveItem();\r\n\tif (Interface.CallHook(\"OnActiveItemChange\", this, activeItem, itemID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.svActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoSwitch",
      "HookName": "OnAmmoSwitch",
      "HookParameters": {
        "BaseProjectile": "this",
        "BasePlayer": "ownerPlayer",
        "ItemDefinition": "ownerPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SwitchAmmoTo",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::ItemModProjectile component = itemDefinition.GetComponent<global::ItemModProjectile>();\r\n\tif (!component || !component.IsAmmo(this.primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoSwitch\", this, ownerPlayer, itemDefinition) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.primaryMagazine.contents > 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerVoice",
      "HookName": "OnPlayerVoice",
      "HookParameters": {
        "BasePlayer": "this",
        "Byte[]": "data"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceivedVoice",
        "ReturnType": "void",
        "Arguments": {
          "data": "System.Byte[]"
        }
      },
      "CodeAfterInjection": "public void OnReceivedVoice(byte[] data)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerVoice\", this, data) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_1A = Network.Net.sv.StartWrite();\r\n\texpr_1A.PacketID(Message.Type.VoiceData);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [FlameTurret] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (component.transform.position.y <= this.GetEyePosition().y + 0.5f && !component.IsBuildingAuthed())\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [GunTrap] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping() && component.IsAlive())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!component.IsBuildingAuthed())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiftUse [ProceduralLift]",
      "HookName": "OnLiftUse",
      "HookParameters": {
        "ProceduralLift": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ProceduralLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.IsBusy())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [LootableCorpse]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "LootableCorpse": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_LootCorpse",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.containers == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [ResourceContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "ResourceContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingContainer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.lootable)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(base.baseEntity, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [DroppedItemContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "DroppedItemContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (!player || !player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityBuilt",
      "HookName": "OnEntityBuilt",
      "HookParameters": {
        "Planner": "this",
        "GameObject": "ownerPlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "void",
        "Arguments": {
          "target": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\townerPlayer.ChatMessage(\"Can't place: \" + global::Construction.lastPlacementError);\r\n\t}\r\n\tif (gameObject != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnEntityBuilt\", this, gameObject);\r\n\t\tglobal::Deployable deployable = this.GetDeployable();\r\n\t\tglobal::BaseEntity baseEntity = gameObject.ToBaseEntity();\r\n\t\tif (deployable != null)\r\n\t\t{\r\n\t\t\tif (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [Door]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "Door": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_KnockDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tcomponent.Knock(rpc.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tglobal::Effect.server.Run(this.knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnLootEntity [patch]",
      "HookName": "OnLootEntity [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tAssert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tthis.PositionChecks = doPositionChecks;\r\n\tthis.entitySource = targetEntity;\r\n\tthis.itemSource = null;\r\n\tInterface.CallHook(\"OnLootEntity\", this, targetEntity);\r\n\tthis.MarkDirty();\r\n\tglobal::ILootableEntity lootableEntity;\r\n\tif ((lootableEntity = (targetEntity as global::ILootableEntity)) != null)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnLootItem [patch]",
      "HookName": "OnLootItem [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.PositionChecks = true;\r\n\tthis.containers.Add(item.contents);\r\n\titem.contents.onDirty += new System.Action(this.MarkDirty);\r\n\tthis.itemSource = item;\r\n\tthis.entitySource = item.GetWorldEntity();\r\n\tInterface.CallHook(\"OnLootItem\", this, item);\r\n\tthis.MarkDirty();\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerAttack [melee, patch]",
      "HookName": "OnPlayerAttack [melee, patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void DoAttackShared(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnNpcTarget [BaseNpc]",
      "HookName": "IOnNpcTarget",
      "HookParameters": {
        "BaseNpc": "this",
        "BaseEntity": "target"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetWantsToAttack",
        "ReturnType": "float",
        "Arguments": {
          "target": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public float GetWantsToAttack(global::BaseEntity target)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"IOnNpcTarget\", this, target);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\treturn this.WantsToAttack(target);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHackCrate",
      "HookName": "CanHackCrate",
      "HookParameters": {
        "BasePlayer": "player",
        "HackableLockedCrate": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "HackableLockedCrate",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Hack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsBeingHacked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanHackCrate\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\r\n\tthis.OriginalHackerPlayer = msg.player.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHack",
      "HookName": "OnCrateHack",
      "HookParameters": {
        "HackableLockedCrate": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartHacking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void StartHacking()\r\n{\r\n\tInterface.CallHook(\"OnCrateHack\", this);\r\n\tbase.BroadcastEntityMessage(\"HackingStarted\", 20f, 256);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);\r\n\tbase.InvokeRepeating(new System.Action(this.HackProgress), 1f, 1f);\r\n\tbase.ClientRPC<int, int>(null, \"UpdateHackProgress\", 0, (int)global::HackableLockedCrate.requiredHackSeconds);\r\n\tthis.RefreshDecay();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHackEnd",
      "HookName": "OnCrateHackEnd",
      "HookParameters": {
        "HackableLockedCrate": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "HackProgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void HackProgress()\r\n{\r\n\tthis.hackSeconds += 1f;\r\n\tif (this.hackSeconds > global::HackableLockedCrate.requiredHackSeconds)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateHackEnd\", this);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(this.OriginalHackerPlayer, this);\r\n\t\tthis.RefreshDecay();\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\t\tthis.isLootable = true;\r\n\t\tbase.CancelInvoke(new System.Action(this.HackProgress));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateLanded",
      "HookName": "OnCrateLanded",
      "HookParameters": {
        "HackableLockedCrate": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "LandCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void LandCheck()\r\n{\r\n\tif (this.hasLanded)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateLanded\", this);\r\n\t\treturn;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n\tif (Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out raycastHit, 1f, 1218511105))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateDropped",
      "HookName": "OnCrateDropped",
      "HookParameters": {
        "HackableLockedCrate": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SetWasDropped",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void SetWasDropped()\r\n{\r\n\tthis.wasDropped = true;\r\n\tInterface.CallHook(\"OnCrateDropped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStart",
      "HookName": "OnExperimentStart",
      "HookParameters": {
        "Workbench": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentStart\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterDropCrate",
      "HookName": "CanHelicopterDropCrate",
      "HookParameters": {
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanDropCrate",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanDropCrate()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterDropCrate\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates > 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropCrate",
      "HookName": "OnHelicopterDropCrate",
      "HookParameters": {
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DropCrate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tVector3 pos = base.transform.position + Vector3.down * 5f;\r\n\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.lockedCratePrefab.resourcePath, pos, rot, true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tInterface.CallHook(\"OnHelicopterDropCrate\", this);\r\n\t\tbaseEntity.SendMessage(\"SetWasDropped\");\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tthis.numCrates--;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterAttack",
      "HookName": "OnHelicopterAttack",
      "HookParameters": {
        "CH47HelicopterAIController": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.OnAttacked(info);\r\n\tthis.InitiateAnger();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [CH47Helicopter]",
      "HookName": "OnEntityDestroy",
      "HookParameters": {
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnKilled(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.OutOfCrates())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterOutOfCrates",
      "HookName": "OnHelicopterOutOfCrates",
      "HookParameters": {
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OutOfCrates",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool OutOfCrates()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnHelicopterOutOfCrates\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates <= 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropDoorOpen",
      "HookName": "OnHelicopterDropDoorOpen",
      "HookParameters": {
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetDropDoorOpen",
        "ReturnType": "void",
        "Arguments": {
          "open": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDropDoorOpen(bool open)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterDropDoorOpen\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, open, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRenameBed",
      "HookName": "CanRenameBed",
      "HookParameters": {
        "BasePlayer": "player",
        "SleepingBag": "this",
        "string": "text"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Rename",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"CanRenameBed\", msg.player, this, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttext = global::WordFilter.Filter(text);\r\n\tif (string.IsNullOrEmpty(text))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAddVendingOffer",
      "HookName": "OnAddVendingOffer",
      "HookParameters": {
        "VendingMachine": "this",
        "SellOrder": "itemDefinition"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "AddSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "itemToSellID": "int",
          "itemToSellAmount": "int",
          "currencyToUseID": "int",
          "currencyAmount": "int",
          "bpState": "byte"
        }
      },
      "CodeAfterInjection": "...\r\n\tsellOrder.itemToSellAmount = itemToSellAmount;\r\n\tsellOrder.currencyID = currencyToUseID;\r\n\tsellOrder.currencyAmountPerItem = currencyAmount;\r\n\tsellOrder.currencyIsBP = (bpState == 3 || bpState == 2);\r\n\tsellOrder.itemToSellIsBP = (bpState == 3 || bpState == 1);\r\n\tInterface.CallHook(\"OnAddVendingOffer\", this, sellOrder);\r\n\tthis.sellOrders.sellOrders.Add(sellOrder);\r\n\tthis.RefreshSellOrderStockLevel(itemDefinition);\r\n\tthis.UpdateMapMarker();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameThrowerBurn",
      "HookName": "OnFlameThrowerBurn",
      "HookParameters": {
        "FlameThrower": "this",
        "BaseEntity": "num"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameThrower",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextFlameTime = Time.realtimeSinceStartup + 0.45f;\r\n\t\tVector3 point = raycastHit.point;\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.fireballPrefab.resourcePath, point - ray.direction * 0.25f, default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnFlameThrowerBurn\", this, baseEntity);\r\n\t\t\tbaseEntity.creatorEntity = ownerPlayer;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tif (this.ammo == 0)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallDamage",
      "HookName": "OnFireBallDamage",
      "HookParameters": {
        "FireBall": "this",
        "BaseCombatEntity": "list",
        "HitInfo": "list"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoRadialDamage",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\tglobal::Effect.server.Run(\"assets/bundled/prefabs/fx/impacts/additive/fire.prefab\", baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up, null, false);\r\n\t\t\t\t}\r\n\t\t\t\thitInfo.PointEnd = baseCombatEntity.transform.position;\r\n\t\t\t\thitInfo.HitPositionWorld = baseCombatEntity.transform.position;\r\n\t\t\t\thitInfo.damageTypes.Set(Rust.DamageType.Heat, this.damagePerSecond * this.tickRate);\r\n\t\t\t\tInterface.CallHook(\"OnFireBallDamage\", this, baseCombatEntity, hitInfo);\r\n\t\t\t\tbaseCombatEntity.OnAttacked(hitInfo);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tPool.FreeList<Collider>(ref list);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallSpread",
      "HookName": "OnFireBallSpread",
      "HookParameters": {
        "FireBall": "this",
        "BaseEntity": "num"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "TryToSpread",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbaseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up, true);\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tInterface.CallHook(\"OnFireBallSpread\", this, baseEntity);\r\n\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\r\n\t\t\tbaseEntity.SendMessage(\"SetGeneration\", this.generation + 1f);\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerMetabolize",
      "HookName": "OnPlayerMetabolize",
      "HookParameters": {
        "PlayerMetabolism": "this",
        "BaseCombatEntity": "ownerEntity",
        "float": "delta"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerUpdate",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "public override void ServerUpdate(global::BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tbase.ServerUpdate(ownerEntity, delta);\r\n\tInterface.CallHook(\"OnPlayerMetabolize\", this, ownerEntity, delta);\r\n\tthis.SendChangesToClient();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile",
      "HookName": "OnEntityMarkHostile",
      "HookParameters": {
        "BaseCombatEntity": "this",
        "Single": "duration"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public virtual void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat b = Time.realtimeSinceStartup + duration;\r\n\tthis.unHostileTime = Mathf.Max(this.unHostileTime, b);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile",
      "HookName": "CanEntityBeHostile",
      "HookParameters": {
        "BaseCombatEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.unHostileTime > Time.realtimeSinceStartup;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile [BasePlayer]",
      "HookName": "CanEntityBeHostile",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.State.unHostileTimestamp > TimeEx.currentTimestamp;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SetMaxHealthBasePlayer [patch]",
      "HookName": "SetMaxHealthBasePlayer [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "MaxHealth",
        "ReturnType": "float",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnItemRemove",
      "HookName": "OnItemRemove",
      "HookParameters": {
        "Item": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "fTime": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.removeTime > 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRemove\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.isServer)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "ICanPickupEntity [DoorCloser]",
      "HookName": "ICanPickupEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "DoorCloser": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "DoorCloser",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Take",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Take(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"ICanPickupEntity\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreate",
      "HookName": "OnTeamCreate",
      "HookParameters": {
        "BasePlayer": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = arg.Player();\r\n\tif (basePlayer.currentTeam != 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamCreate\", basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tplayerTeam.teamLeader = basePlayer.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamRejectInvite",
      "HookName": "OnTeamRejectInvite",
      "HookParameters": {
        "BasePlayer": "basePlayer",
        "PlayerTeam": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "rejectinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamRejectInvite\", basePlayer, playerTeam) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RejectInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamPromote",
      "HookName": "OnTeamPromote",
      "HookParameters": {
        "PlayerTeam": "basePlayer",
        "BasePlayer": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "promote",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (lookingAtPlayer.currentTeam == basePlayer.currentTeam)\r\n\t{\r\n\t\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.teams[basePlayer.currentTeam];\r\n\t\tif (playerTeam != null && playerTeam.teamLeader == basePlayer.userID)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTeamPromote\", playerTeam, lookingAtPlayer) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tplayerTeam.SetTeamLeader(lookingAtPlayer.userID);\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamLeave",
      "HookName": "OnTeamLeave",
      "HookParameters": {
        "PlayerTeam": "basePlayer",
        "BasePlayer": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "leaveteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\tif (playerTeam != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTeamLeave\", playerTeam, basePlayer) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.RemovePlayer(basePlayer.userID);\r\n\t\tbasePlayer.ClearTeam();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamKick",
      "HookName": "OnTeamKick",
      "HookParameters": {
        "PlayerTeam": "basePlayer",
        "BasePlayer": "basePlayer",
        "ulong": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "kickmember",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong uLong = arg.GetULong(0, 0uL);\r\n\tif (basePlayer.userID == uLong)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamKick\", playerTeam, basePlayer, uLong) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RemovePlayer(uLong);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamAcceptInvite",
      "HookName": "OnTeamAcceptInvite",
      "HookParameters": {
        "PlayerTeam": "basePlayer",
        "BasePlayer": "basePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "acceptinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamAcceptInvite\", playerTeam, basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.AcceptInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisband",
      "HookName": "OnTeamDisband",
      "HookParameters": {
        "PlayerTeam": "teamToDisband"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "public void DisbandTeam(global::RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tPool.Free<global::RelationshipManager.PlayerTeam>(ref teamToDisband);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreated",
      "HookName": "OnTeamCreated",
      "HookParameters": {
        "BasePlayer": "basePlayer",
        "RelationshipManager": "relationshipManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer basePlayer = arg.Player();\r\n\tif (basePlayer.currentTeam != 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamCreate\", basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tplayerTeam.teamLeader = basePlayer.userID;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisbanded",
      "HookName": "OnTeamDisbanded",
      "HookParameters": {
        "PlayerTeam": "teamToDisband"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "public void DisbandTeam(global::RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tPool.Free<global::RelationshipManager.PlayerTeam>(ref teamToDisband);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLand",
      "HookName": "OnPlayerLand",
      "HookParameters": {
        "BasePlayer": "this",
        "float": "num"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerLand\", this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.metabolism.bleeding.Add(num * 0.5f);\r\n\tfloat num2 = num * 500f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLanded",
      "HookName": "OnPlayerLanded",
      "HookParameters": {
        "BasePlayer": "this",
        "float": "num"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerLand\", this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.metabolism.bleeding.Add(num * 0.5f);\r\n\tfloat num2 = num * 500f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDeployItem",
      "HookName": "CanDeployItem",
      "HookParameters": {
        "BasePlayer": "player",
        "Deployer": "this",
        "NetworkableId": "deployable"
      },
      "ReturnBehavior": 1,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tRay ray = msg.read.Ray();\r\n\tNetworkableId networkableId = msg.read.EntityID();\r\n\tif (Interface.CallHook(\"CanDeployItem\", msg.player, this, networkableId) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (deployable.toSlot)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSamSiteShoot",
      "HookName": "CanSamSiteShoot",
      "HookParameters": {
        "SamSite": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WeaponTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextBurstTime = Time.time + timeBetweenBursts;\r\n\t\tthis.firedCount = 0;\r\n\t\treturn;\r\n\t}\r\n\tthis.EnsureReloaded();\r\n\tif (Interface.CallHook(\"CanSamSiteShoot\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasAmmo())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldPrefabSpawned",
      "HookName": "OnWorldPrefabSpawned",
      "HookParameters": {
        "GameObject": "gameObject",
        "string": "category"
      },
      "ReturnBehavior": 0,
      "TargetType": "World",
      "Category": "World",
      "MethodData": {
        "MethodName": "Spawn",
        "ReturnType": "void",
        "Arguments": {
          "category": "string",
          "prefab": "Prefab",
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "scale": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\r\n\t}\r\n\tGameObject gameObject = prefab.Spawn(position, rotation, scale, true);\r\n\tif (gameObject)\r\n\t{\r\n\t\tInterface.CallHook(\"OnWorldPrefabSpawned\", gameObject, category);\r\n\t\tgameObject.SetHierarchyGroup(category, true, false);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoatPathGenerate",
      "HookName": "OnBoatPathGenerate",
      "HookParameters": {
        "BaseBoat": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseBoat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "GenerateOceanPatrolPath",
        "ReturnType": "System.Collections.Generic.List`1<UnityEngine.Vector3>",
        "Arguments": {
          "minDistanceFromShore": "float",
          "minWaterDepth": "float"
        }
      },
      "CodeAfterInjection": "public static System.Collections.Generic.List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBoatPathGenerate\");\r\n\tif (returnvar is System.Collections.Generic.List<Vector3>)\r\n\t{\r\n\t\treturn (System.Collections.Generic.List<Vector3>)returnvar;\r\n\t}\r\n\tfloat expr_28 = global::TerrainMeta.Size.x;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCollectiblePickup",
      "HookName": "OnCollectiblePickup",
      "HookParameters": {
        "CollectibleEntity": "this",
        "BasePlayer": "reciever",
        "bool": "eat"
      },
      "ReturnBehavior": 1,
      "TargetType": "CollectibleEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "DoPickup",
        "ReturnType": "void",
        "Arguments": {
          "reciever": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCollectiblePickup\", this, reciever, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemAmount[] array = this.itemList;\r\n\tfor (int i = 0; i < array.Length; i++)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnProjectileRicochet",
      "HookName": "OnProjectileRicochet",
      "HookParameters": {
        "BasePlayer": "this",
        "PlayerProjectileRicochet": "playerProjectileRicochet"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "OnProjectileRicochet",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(this, global::AntiHackType.ProjectileHack, \"Lifetime is zero (\" + playerProjectileRicochet.projectileID + \")\");\r\n\t\tplayerProjectileRicochet.ResetToPool();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnProjectileRicochet\", this, playerProjectileRicochet) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfiredProjectile.ricochets++;\r\n\tthis.firedProjectiles[playerProjectileRicochet.projectileID] = firedProjectile;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAffordToPlace",
      "HookName": "CanAffordToPlace",
      "HookParameters": {
        "BasePlayer": "ownerPlayer",
        "Planner": "this",
        "Construction": "component"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanAffordToPlace",
        "ReturnType": "bool",
        "Arguments": {
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAffordToPlace\", ownerPlayer, this, component);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tforeach (global::ItemAmount current in component.defaultGrade.costToBuild)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSpectateTarget",
      "HookName": "CanSpectateTarget",
      "HookParameters": {
        "BasePlayer": "this",
        "string": "strName"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateSpectateTarget",
        "ReturnType": "void",
        "Arguments": {
          "strName": "string"
        }
      },
      "CodeAfterInjection": "public void UpdateSpectateTarget(string strName)\r\n{\r\n\tif (Interface.CallHook(\"CanSpectateTarget\", this, strName) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.spectateFilter = strName;\r\n\tSystem.Collections.Generic.IEnumerable<global::BaseEntity> source;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [ElectricSwitch]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "ElectricSwitch": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopAcceptClick",
      "HookName": "OnShopAcceptClick",
      "HookParameters": {
        "ShopFront": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "AcceptClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.vendorPlayer == null || this.customerPlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopAcceptClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsPlayerVendor(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCancelClick",
      "HookName": "OnShopCancelClick",
      "HookParameters": {
        "ShopFront": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CancelClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsTradingPlayer(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopCancelClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.vendorPlayer;\r\n\tthis.customerPlayer;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending [NPC]",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "BasePlayer": "player",
        "NPCVendingMachine": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanPlayerAdmin(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\treturn returnvar is bool && (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGiveSoldItem",
      "HookName": "OnGiveSoldItem",
      "HookParameters": {
        "VendingMachine": "this",
        "Item": "soldItem",
        "BasePlayer": "buyer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbuyer.GiveItem(soldItem, global::BaseEntity.GiveItemReason.PickedUp);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "Connection": "cn",
        "string": "strCommand",
        "Object[]": "args"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "Network.Connection",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand [list]",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "List`1": "cn",
        "string": "strCommand",
        "Object[]": "args"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "System.Collections.Generic.List`1<Network.Connection>",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBroadcastCommand",
      "HookName": "OnBroadcastCommand",
      "HookParameters": {
        "string": "strCommand",
        "Object[]": "args"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "BroadcastToAllClients",
        "ReturnType": "void",
        "Arguments": {
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBroadcastCommand\", strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_27 = Net.sv.StartWrite();\r\n\texpr_27.PacketID(Message.Type.ConsoleCommand);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopRename",
      "HookName": "OnVendingShopRename",
      "HookParameters": {
        "VendingMachine": "this",
        "string": "player",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_UpdateShopName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tstring obj = msg.read.String(32);\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVendingShopRename\", this, obj, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.shopName = obj;\r\n\t\tthis.UpdateMapMarker();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcGiveSoldItem",
      "HookName": "OnNpcGiveSoldItem",
      "HookParameters": {
        "NPCVendingMachine": "this",
        "Item": "soldItem",
        "BasePlayer": "buyer"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.GiveSoldItem(soldItem, buyer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorGather",
      "HookName": "OnExcavatorGather",
      "HookParameters": {
        "ExcavatorArm": "this",
        "Item": "num"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProduceResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)this.outputPiles.Count);\r\n\t\t\titemAmount.amount -= (float)(num3 * 2);\r\n\t\t\tforeach (global::ExcavatorOutputPile current in this.outputPiles)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(this.resourcesToMine[this.resourceMiningIndex].itemDef, num3, 0uL);\r\n\t\t\t\tif (Interface.CallHook(\"OnExcavatorGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\r\n\t\t\t\tif (!item.MoveToContainer(current.inventory, -1, true, false, null, true))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityTakeDamage [ResourceEntity]",
      "HookName": "OnEntityTakeDamage",
      "HookParameters": {
        "ResourceEntity": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (base.isServer && !this.isKilled)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityTakeDamage\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.resourceDispenser != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropLanded",
      "HookName": "OnSupplyDropLanded",
      "HookParameters": {
        "SupplyDrop": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplyDrop",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnCollisionEnter",
        "ReturnType": "void",
        "Arguments": {
          "collision": "UnityEngine.Collision"
        }
      },
      "CodeAfterInjection": "...\r\n\tif ((1 << collision.collider.gameObject.layer & 1084293393) > 0)\r\n\t{\r\n\t\tthis.RemoveParachute();\r\n\t\tthis.MakeLootable();\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropLanded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterStrafeEnter",
      "HookName": "OnHelicopterStrafeEnter",
      "HookParameters": {
        "PatrolHelicopterAI": "this",
        "Vector3": "strafePos"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "State_Strafe_Enter",
        "ReturnType": "void",
        "Arguments": {
          "strafePos": "UnityEngine.Vector3",
          "shouldUseNapalm": "bool"
        }
      },
      "CodeAfterInjection": "public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterStrafeEnter\", this, strafePos) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.CanUseNapalm() & shouldUseNapalm)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "VendingMachine": "this",
        "Item": "takenCurrencyItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public virtual void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!takenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem [NPC]",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "NPCVendingMachine": "this",
        "Item": "takenCurrencyItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public override void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttakenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true);\r\n\ttakenCurrencyItem.RemoveFromContainer();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityStabilityCheck",
      "HookName": "OnEntityStabilityCheck",
      "HookParameters": {
        "StabilityEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "StabilityEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StabilityCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.IsDestroyed)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityStabilityCheck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.supports == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForPlacement",
      "HookName": "OnPayForPlacement",
      "HookParameters": {
        "BasePlayer": "player",
        "Planner": "this",
        "Construction": "component"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForPlacement",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "public void PayForPlacement(global::BasePlayer player, global::Construction component)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForPlacement\", player, this, component) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.isTypeDeployable)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [ResourceEntity]",
      "HookName": "OnEntityDeath",
      "HookParameters": {
        "ResourceEntity": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void OnKilled(global::HitInfo info)\r\n{\r\n\tthis.isKilled = true;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnExplosiveDud",
      "HookName": "OnExplosiveDud",
      "ReturnBehavior": 0,
      "TargetType": "DudTimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.creatorEntity != null && this.creatorEntity.IsNpc)\r\n\t{\r\n\t\tbase.Explode();\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Random.Range(0f, 1f) < this.dudChance && Interface.CallHook(\"OnExplosiveDud\", this) == null)\r\n\t{\r\n\t\tthis.BecomeDud();\r\n\t\treturn;\r\n\t}\r\n\tbase.Explode();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [start]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "ExcavatorArm": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "BeginMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tthis.nextNotificationTime = Time.time + 60f;\r\n\t}\r\n\tglobal::ExcavatorServerEffects.SetMining(true, false);\r\n\tFacepunch.Rust.Analytics.Server.ExcavatorStarted();\r\n\tthis.excavatorStartTime = this.GetNetworkTime();\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [stop]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "ExcavatorArm": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.HasFlag(global::BaseEntity.Flags.On))\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Server.ExcavatorStopped(this.GetNetworkTime() - this.excavatorStartTime);\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorResourceSet",
      "HookName": "OnExcavatorResourceSet",
      "HookParameters": {
        "ExcavatorArm": "this",
        "string": "text",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RPC_SetResourceTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SetResourceTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnExcavatorResourceSet\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (text == \"HQM\")\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [off]",
      "HookName": "OnDieselEngineToggled",
      "HookParameters": {
        "DieselEngine": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOff",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOff()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOff\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [on]",
      "HookName": "OnDieselEngineToggled",
      "HookParameters": {
        "DieselEngine": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOn()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOn\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggle",
      "HookName": "OnDieselEngineToggle",
      "HookParameters": {
        "DieselEngine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(6f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnDieselEngineToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (msg.read.Bit())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoUnload",
      "HookName": "OnAmmoUnload",
      "HookParameters": {
        "BaseProjectile": "component",
        "Item": "item",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "UnloadAmmo",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseProjectile component = item.GetHeldEntity().GetComponent<global::BaseProjectile>();\r\n\tif (!component.canUnloadAmmo)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoUnload\", component, item, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (component)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOutputUpdate",
      "HookName": "OnOutputUpdate",
      "HookParameters": {
        "IOEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "IOEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdateOutputs",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void UpdateOutputs()\r\n{\r\n\tif (Interface.CallHook(\"OnOutputUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.ShouldUpdateOutputs())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCardSwipe",
      "HookName": "OnCardSwipe",
      "HookParameters": {
        "CardReader": "this",
        "Keycard": "uid",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "CardReader",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ServerCardSwiped",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tNetworkableId uid = msg.read.EntityID();\r\n\tglobal::Keycard keycard = global::BaseNetworkable.serverEntities.Find(uid) as global::Keycard;\r\n\tglobal::Effect.server.Run(this.swipeEffect.resourcePath, this.audioPosition.position, Vector3.up, msg.player.net.connection, false);\r\n\tif (keycard != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnCardSwipe\", this, keycard, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::Item item = keycard.GetItem();\r\n\t\tif (item != null && keycard.accessLevel == this.accessLevel && item.conditionNormalized > 0f)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnButtonPress",
      "HookName": "OnButtonPress",
      "HookParameters": {
        "PressButton": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "PressButton",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Press",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.IsOn())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnButtonPress\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.Invoke(new System.Action(this.UnpowerTime), this.pressPowerTime);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkersCleared",
      "HookName": "OnMapMarkersCleared",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_ClearMapMarkers",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_ClearMapMarkers(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkersClear\", this, this.State.pointsOfInterest) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tMapNote expr_20 = this.ServerCurrentDeathNote;\r\n\tif (expr_20 != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo [BaseEntity]",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "BaseEntity": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Network",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!(parentEntity != null))\r\n\t{\r\n\t\treturn base.ShouldNetworkTo(player);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn parentEntity.ShouldNetworkTo(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerCommand",
      "HookName": "IOnPlayerCommand",
      "HookParameters": {
        "BasePlayer": "player",
        "string": "message"
      },
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Chat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "sayAs",
        "ReturnType": "bool",
        "Arguments": {
          "targetChannel": "ConVar.Chat/ChatChannel",
          "userId": "ulong",
          "username": "string",
          "message": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (text.StartsWith(\"/\") || text.StartsWith(\"\\\\\"))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerCommand\", player, message);\r\n\t\treturn false;\r\n\t}\r\n\ttext = text.EscapeRichText();\r\n\tif (Chat.serverlog)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseWires",
      "HookName": "CanUseWires",
      "HookParameters": {
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanPlayerUseWires",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public static bool CanPlayerUseWires(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseWires\", player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!player.CanBuild())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseLead",
      "HookName": "OnHorseLead",
      "HookParameters": {
        "BaseRidableAnimal": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_Lead",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (arg_36_0 == flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHorseLead\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetLeading(flag ? player : null);\r\n\tthis.LeadingChanged();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneNameUpdate",
      "HookName": "OnPhoneNameUpdate",
      "HookParameters": {
        "PhoneController": "this",
        "string": "text",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePhoneName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tstring text = msg.read.String(256);\r\n\tif (text.Length > 20)\r\n\t{\r\n\t\ttext = text.Substring(0, 20);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneNameUpdate\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PhoneName = text;\r\n\tbase.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [on]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StartEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(true);\r\n\t\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [off]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tminingQuarry.EngineSwitch(false);\r\n\t\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingPrivilege",
      "HookName": "OnBuildingPrivilege",
      "HookParameters": {
        "BaseEntity": "this",
        "OBB": "obb"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetBuildingPrivilege",
        "ReturnType": "BuildingPrivlidge",
        "Arguments": {
          "obb": "OBB"
        }
      },
      "CodeAfterInjection": "public global::BuildingPrivlidge GetBuildingPrivilege(OBB obb)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBuildingPrivilege\", this, obb);\r\n\tif (returnvar is global::BuildingPrivlidge)\r\n\t{\r\n\t\treturn (global::BuildingPrivlidge)returnvar;\r\n\t}\r\n\tglobal::BuildingBlock other = null;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Network",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPCEx<int>(new SendInfo(this.net.group.subscribers)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "arg": "string",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPCEx<int, string>(new SendInfo(this.net.group.subscribers)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterRetire",
      "HookName": "OnHelicopterRetire",
      "HookParameters": {
        "PatrolHelicopterAI": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Retire",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.isRetiring)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHelicopterRetire\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.isRetiring = true;\r\n\tbase.Invoke(new System.Action(this.DestroyMe), 240f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipEgress",
      "HookName": "OnCargoShipEgress",
      "HookParameters": {
        "CargoShip": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartEgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.egressing)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCargoShipEgress\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.egressing = true;\r\n\tbase.CancelInvoke(new System.Action(this.PlayHorn));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipSpawnCrate",
      "HookName": "OnCargoShipSpawnCrate",
      "HookParameters": {
        "CargoShip": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RespawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RespawnLoot()\r\n{\r\n\tif (Interface.CallHook(\"OnCargoShipSpawnCrate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new System.Action(this.PlayHorn), 0f, 8f);\r\n\tthis.SpawnCrate(this.lockedCratePrefab.resourcePath);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcRadioChatter [ScientistNPC]",
      "HookName": "OnNpcRadioChatter",
      "HookParameters": {
        "ScientistNPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "PlayRadioChatter",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.IsDestroyed || base.transform == null)\r\n\t{\r\n\t\tbase.CancelInvoke(new System.Action(this.PlayRadioChatter));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNpcRadioChatter\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect.server.Run(this.RadioChatterEffects[UnityEngine.Random.Range(0, this.RadioChatterEffects.Length)].resourcePath, this, global::StringPool.Get(\"head\"), Vector3.zero, Vector3.zero, null, false);\r\n\tthis.QueueRadioChatter();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcAlert [ScientistNPC]",
      "HookName": "OnNpcAlert",
      "HookParameters": {
        "ScientistNPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Alert",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Alert()\r\n{\r\n\tif (Interface.CallHook(\"OnNpcAlert\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.lastAlertedTime = Time.time;\r\n\tthis.SetChatterType(global::ScientistNPC.RadioChatterType.Alert);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [BradleyAPC]",
      "HookName": "OnEntityDestroy",
      "HookParameters": {
        "BradleyAPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnKilled",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CreateExplosionMarker(10f);\r\n\tglobal::Effect.server.Run(this.explosionEffect.resourcePath, this.mainTurretEyePos.transform.position, Vector3.up, null, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [NPCPlayer]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "NPCPlayer": "this",
        "Item": "slot"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCPlayer",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.inventory == null || this.inventory.containerBelt == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = this.inventory.containerBelt.GetSlot(0);\r\n\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, slot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (slot != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [ScientistNPC]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "ScientistNPC": "this",
        "Item": "heldEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (heldEntity != null)\r\n\t{\r\n\t\tglobal::Item item = heldEntity.GetItem();\r\n\t\tif (item != null && item.contents != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, item) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 3) == 0)\r\n\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcDuck [HumanNPC]",
      "HookName": "OnNpcDuck",
      "HookParameters": {
        "HumanNPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SetDucked",
        "ReturnType": "void",
        "Arguments": {
          "flag": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDucked(bool flag)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcDuck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.modelState.ducked = flag;\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [BaseCombatEntity]",
      "HookName": "OnEntityDeath",
      "HookParameters": {
        "BaseCombatEntity": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tDebug.Log(\"[Combat]\".PadRight(10) + base.gameObject.name + \" died\");\r\n\t}\r\n\tthis.health = 0f;\r\n\tthis.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tif (info != null && info.InitiatorPlayer)\r\n\t{\r\n\t\tglobal::BasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [FuelGenerator]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "FuelGenerator": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsDismount",
      "HookName": "OnPlayerWantsDismount",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AttemptDismount(player);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsMount",
      "HookName": "OnPlayerWantsMount",
      "HookParameters": {
        "BaseVehicle": "baseVehicle",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "WantsMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbaseVehicle.WantsMount(player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsMount\", baseVehicle, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AttemptMount(player, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerStudyBlueprint",
      "HookName": "OnPlayerStudyBlueprint",
      "HookParameters": {
        "BasePlayer": "player",
        "Item": "item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModStudyBlueprint",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (flag2)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnPlayerStudyBlueprint\", player, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::Item item2 = item;\r\n\t\tif (item.amount > 1)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerConnected",
      "HookName": "IOnPlayerConnected",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerInit",
        "ReturnType": "void",
        "Arguments": {
          "c": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.net != null)\r\n\t\t{\r\n\t\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t\t}\r\n\t\tInterface.CallHook(\"IOnPlayerConnected\", this);\r\n\t\tif (this.IsAdmin)\r\n\t\t{\r\n\t\t\tif (ConVar.AntiHack.noclip_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tthis.ChatMessage(\"antihack.noclip_protection is disabled!\");\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile [BasePlayer]",
      "HookName": "OnEntityMarkHostile",
      "HookParameters": {
        "BasePlayer": "this",
        "Single": "duration"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public override void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tdouble currentTimestamp = TimeEx.currentTimestamp;\r\n\tdouble val = currentTimestamp + (double)duration;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingSplit",
      "HookName": "OnBuildingSplit",
      "HookParameters": {
        "Building": "building",
        "uint": "newID"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerBuildingManager",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Split",
        "ReturnType": "void",
        "Arguments": {
          "building": "BuildingManager/Building"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\twhile (building.HasBuildingBlocks())\r\n\t{\r\n\t\tglobal::BaseEntity arg_47_0 = building.buildingBlocks[0];\r\n\t\tuint newID = global::BuildingManager.server.NewBuildingID();\r\n\t\tInterface.CallHook(\"OnBuildingSplit\", building, newID);\r\n\t\targ_47_0.EntityLinkBroadcast<global::BuildingBlock>(delegate(global::BuildingBlock b)\r\n\t\t{\r\n\t\t\tb.AttachToBuilding(newID);\r\n\t\t});\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityActiveCheck",
      "HookName": "OnEntityActiveCheck",
      "HookParameters": {
        "BaseEntity": "ent",
        "BasePlayer": "player",
        "uint": "id",
        "string": "debugName"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsActiveItem",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityActiveCheck\", ent, player, id, debugName);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (ent.net.ID == player.net.ID)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityFromOwnerCheck",
      "HookName": "OnEntityFromOwnerCheck",
      "HookParameters": {
        "BaseEntity": "ent",
        "BasePlayer": "player",
        "uint": "id",
        "string": "debugName"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/FromOwner",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityFromOwnerCheck\", ent, player, id, debugName);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn ent.net.ID == player.net.ID || !(ent.parentEntity.uid != player.net.ID);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [BaseRidableAnimal]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseRidableAnimal": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTarget",
      "HookName": "OnSamSiteTarget",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tthis.<TargetScan>g__AddTargetSet|55_0(list, 1048576, global::SamSite.targetTypeMissile.scanRadius);\r\n\tglobal::SamSite.ISamSiteTarget samSiteTarget = null;\r\n\tforeach (global::SamSite.ISamSiteTarget current in list)\r\n\t{\r\n\t\tif (!current.isClient && current.CenterPoint().y >= this.eyePoint.transform.position.y && current.IsVisible(this.eyePoint.transform.position, current.SAMTargetType.scanRadius * 2f) && current.IsValidSAMTarget(this.staticRespawn) && Interface.CallHook(\"OnSamSiteTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tsamSiteTarget = current;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [StorageContainer]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityVisibilityCheck",
      "HookName": "OnEntityVisibilityCheck",
      "HookParameters": {
        "BaseEntity": "ent",
        "BasePlayer": "player",
        "uint": "id",
        "string": "debugName",
        "float": "maximumDistance"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsVisible",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityVisibilityCheck\", ent, player, id, debugName, maximumDistance);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn global::GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688, null) && (ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance) || ent.IsVisible(player.eyes.position, maximumDistance));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDistanceCheck",
      "HookName": "OnEntityDistanceCheck",
      "HookParameters": {
        "BaseEntity": "ent",
        "BasePlayer": "player",
        "uint": "id",
        "string": "debugName",
        "float": "maximumDistance"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/MaxDistance",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityDistanceCheck\", ent, player, id, debugName, maximumDistance);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn ent.Distance(player.eyes.position) <= maximumDistance;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableGather",
      "HookName": "OnGrowableGather",
      "HookParameters": {
        "GrowableEntity": "this",
        "BasePlayer": "player",
        "Boolean": "eat"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "PickFruit",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.CanPick())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnGrowableGather\", this, player, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.harvests++;\r\n\tthis.GiveFruit(player, this.CurrentPickAmount, eat);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryGather",
      "HookName": "OnQuarryGather",
      "ReturnBehavior": 0,
      "TargetType": "MiningQuarry",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProcessResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tif (num2 != num3)\r\n\t\t\t{\r\n\t\t\t\tint iAmount = num3 - num2;\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(current.type, iAmount, 0uL);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\r\n\t\t\t\tif (Interface.CallHook(\"OnQuarryGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Remove(0f);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!item.MoveToContainer(this.hopperPrefab.instance.GetComponent<global::StorageContainer>().inventory, -1, true, false, null, true))\r\n\t\t\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [HumanNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "HumanNPC": "this",
        "NPCPlayerCorpse": "timeWarning"
      },
      "ReturnBehavior": 1,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\titemContainer.Clear();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSkinChange",
      "HookName": "OnItemSkinChange",
      "HookParameters": {
        "int": "<>c__DisplayClass10_",
        "Item": "<>c__DisplayClass10_",
        "RepairBench": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ChangeSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemSkinChange\", num, slot, this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (msg.player.UnlockAllSkins)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "NoLimboGroupForPlayers [patch]",
      "HookName": "NoLimboGroupForPlayers [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateNetworkGroup",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnMapMarkerAdd",
      "HookName": "OnMapMarkerAdd",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(8uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_AddMarker(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkerAdd\", this, MapNote.Deserialize(msg.read)) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmsg.read.Position = 13L;\r\n\tif (this.State.pointsOfInterest == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkerAdded",
      "HookName": "OnMapMarkerAdded",
      "HookParameters": {
        "BasePlayer": "this",
        "MapNote": "mapNote"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(8uL), global::BaseEntity.RPC_Server.FromOwner]\r\npublic void Server_AddMarker(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkerAdd\", this, MapNote.Deserialize(msg.read)) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tmsg.read.Position = 13L;\r\n\tif (this.State.pointsOfInterest == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClothingItemChanged",
      "HookName": "OnClothingItemChanged",
      "HookParameters": {
        "PlayerInventory": "this",
        "Item": "item",
        "bool": "bAdded"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClothingChanged",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "bAdded": "bool"
        }
      },
      "CodeAfterInjection": "private void OnClothingChanged(global::Item item, bool bAdded)\r\n{\r\n\tbase.baseEntity.SV_ClothingChanged();\r\n\tglobal::ItemManager.DoRemoves();\r\n\tthis.ServerUpdate(0f);\r\n\tInterface.CallHook(\"OnClothingItemChanged\", this, item, bAdded);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseHitch",
      "HookName": "OnHorseHitch",
      "HookParameters": {
        "RidableHorse": "horse",
        "HitchSpot": "hitch"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AttemptToHitch",
        "ReturnType": "bool",
        "Arguments": {
          "horse": "RidableHorse",
          "hitch": "HitchTrough/HitchSpot"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (hitch == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnHorseHitch\", horse, hitch);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\thitch.SetOccupiedBy(horse);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseUnhitch",
      "HookName": "OnHorseUnhitch",
      "HookParameters": {
        "RidableHorse": "horse",
        "HitchSpot": "array"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Unhitch",
        "ReturnType": "void",
        "Arguments": {
          "horse": "RidableHorse"
        }
      },
      "CodeAfterInjection": "...\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tglobal::HitchTrough.HitchSpot hitchSpot = array[i];\r\n\t\tif (hitchSpot.GetHorse(base.isServer) == horse)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnHorseUnhitch\", horse, hitchSpot) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thitchSpot.SetOccupiedBy(null);\r\n\t\t\thorse.SetHitch(null);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEventTrigger",
      "HookName": "OnEventTrigger",
      "HookParameters": {
        "TriggeredEventPrefab": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggeredEventPrefab",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RunEvent",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void RunEvent()\r\n{\r\n\tif (Interface.CallHook(\"OnEventTrigger\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(\"[event] \" + this.targetPrefab.resourcePath);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.targetPrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSensorDetect",
      "HookName": "OnSensorDetect",
      "ReturnBehavior": 0,
      "TargetType": "HBHFSensor",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePassthroughAmount",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tforeach (global::BaseEntity current in this.myTrigger.entityContents)\r\n\t\t{\r\n\t\t\tif (!(current == null) && current.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))\r\n\t\t\t{\r\n\t\t\t\tglobal::BasePlayer component = current.GetComponent<global::BasePlayer>();\r\n\t\t\t\tif (Interface.CallHook(\"OnSensorDetect\", this, component) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tbool flag = component.CanBuild();\r\n\t\t\t\t\tif ((!flag || this.ShouldIncludeAuthorized()) && (flag || this.ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.detectedPlayers++;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "FixItemKeyId [patch]",
      "HookName": "FixItemKeyId [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemCraft\", itemCraftTask, owner, fromTempBlueprint);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tthis.queue.AddLast(itemCraftTask);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [ContainerIOEntity]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (this.needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehiclePush",
      "HookName": "OnVehiclePush",
      "HookParameters": {
        "BaseVehicle": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsPush",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.OnlyOwnerAccessible() && player != this.creatorEntity)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVehiclePush\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.metabolism.calories.Subtract(3f);\r\n\tplayer.metabolism.SendChangesToClient();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashHidden",
      "HookName": "OnStashHidden",
      "HookParameters": {
        "StashContainer": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"CanHideStash\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [PhotoFrame]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "BasePlayer": "player",
        "PhotoFrame": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhotoFrame",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [PhotoFrame]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "PhotoFrame": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [PhotoFrame]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "PhotoFrame": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tglobal::FileStorage.server.RemoveAllByEntity(this.net.ID);\r\n\tthis._overlayTextureCrc = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, 0u);\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMixingTableToggle",
      "HookName": "OnMixingTableToggle",
      "HookParameters": {
        "MixingTable": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "MixingTable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprivate void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMixingTableToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == base.IsOn())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControl",
      "HookName": "OnBookmarkControl",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "string": "player",
        "IRemoteControllable": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkDelete",
      "HookName": "OnBookmarkDelete",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "string": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "DeleteBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.controlBookmarks.Contains(text))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkDelete\", this, player, text) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.controlBookmarks.Remove(text);\r\n\t\tthis.SendControlBookmarks(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkAdd",
      "HookName": "OnBookmarkAdd",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "string": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "AddBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tplayer.ChatMessage(\"Too many bookmarks, delete some\");\r\n\t\treturn;\r\n\t}\r\n\tthis.nextAddTime = Time.realtimeSinceStartup + 1f;\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnBookmarkAdd\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ForceAddBookmark(text);\r\n\tthis.SendControlBookmarks(player);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarksSendControl",
      "HookName": "OnBookmarksSendControl",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "string": "text"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "SendControlBookmarks",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = this.GenerateControlBookmarkString();\r\n\tif (Interface.CallHook(\"OnBookmarksSendControl\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPCPlayer<string>(null, player, \"ReceiveBookmarks\", text);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnd",
      "HookName": "OnBookmarkControlEnd",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "ply",
        "BaseEntity": "baseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void StopControl(global::BasePlayer ply)\r\n{\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkControlEnd\", this, ply, baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.GetComponent<global::IRemoteControllable>().StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSolarPanelSunUpdate",
      "HookName": "OnSolarPanelSunUpdate",
      "HookParameters": {
        "SolarPanel": "this",
        "int": "num"
      },
      "ReturnBehavior": 1,
      "TargetType": "SolarPanel",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SunUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tbool arg_B3_0 = this.currentEnergy != num;\r\n\tthis.currentEnergy = num;\r\n\tif (arg_B3_0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSolarPanelSunUpdate\", this, num) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.MarkDirty();\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInitialize",
      "HookName": "OnServerInitialize",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {
          "loadSave": "bool",
          "saveFile": "string",
          "allowOutOfDateSaves": "bool",
          "skipInitialSpawn": "bool"
        }
      },
      "CodeAfterInjection": "public void Initialize(bool loadSave = true, string saveFile = \"\", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\r\n{\r\n\tInterface.CallHook(\"OnServerInitialize\");\r\n\tthis.persistance = new global::UserPersistance(ConVar.Server.rootFolder);\r\n\tthis.playerStateManager = new global::PlayerStateManager(this.persistance);\r\n\tthis.SpawnMapEntities();\r\n\tif (SingletonComponent<global::SpawnHandler>.Instance)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceive",
      "HookName": "OnDefaultItemsReceive",
      "HookParameters": {
        "PlayerInventory": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void GiveDefaultItems()\r\n{\r\n\tif (Interface.CallHook(\"OnDefaultItemsReceive\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Strip();\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceived",
      "HookName": "OnDefaultItemsReceived",
      "HookParameters": {
        "PlayerInventory": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void GiveDefaultItems()\r\n{\r\n\tif (Interface.CallHook(\"OnDefaultItemsReceive\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Strip();\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerBanned [Publisher/VAC]",
      "HookName": "IOnPlayerBanned",
      "HookParameters": {
        "Connection": "<>c__DisplayClass33_",
        "AuthResponse": "Status"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnValidateAuthTicketResponse",
        "ReturnType": "void",
        "Arguments": {
          "SteamId": "ulong",
          "OwnerId": "ulong",
          "Status": "AuthResponse"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((Status == AuthResponse.PublisherBanned || Status == AuthResponse.VACBanned) && !this.bannedPlayerNotices.Contains(SteamId))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerBanned\", connection, Status);\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n\t\t\t2,\r\n\t\t\t0,\r\n\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username.EscapeRichText() + \" (banned by anticheat)\"\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerSpawn",
      "HookName": "OnPlayerSpawn",
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SpawnNewPlayer",
        "ReturnType": "BasePlayer",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "private global::BasePlayer SpawnNewPlayer(Connection connection)\r\n{\r\n\tglobal::BasePlayer.SpawnPoint spawnPoint = global::ServerMgr.FindSpawnPoint(null);\r\n\tglobal::BasePlayer basePlayer = global::GameManager.server.CreateEntity(\"assets/prefabs/player/player.prefab\", spawnPoint.pos, spawnPoint.rot, true).ToPlayer();\r\n\tif (Interface.CallHook(\"OnPlayerSpawn\", basePlayer, connection) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tbasePlayer.health = 0f;\r\n\tbasePlayer.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerCorpseSpawn",
      "HookName": "OnPlayerCorpseSpawn",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual global::BaseCorpse CreateCorpse()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerCorpseSpawn\", this) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tusing (TimeWarning.New(\"Create corpse\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerCorpseSpawned",
      "HookName": "OnPlayerCorpseSpawned",
      "HookParameters": {
        "BasePlayer": "this",
        "PlayerCorpse": "timeWarning"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual global::BaseCorpse CreateCorpse()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerCorpseSpawn\", this) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tusing (TimeWarning.New(\"Create corpse\", 0))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRefill",
      "HookName": "OnItemRefill",
      "HookParameters": {
        "Item": "item",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModRepair",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (item.conditionNormalized >= 1f)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemRefill\", item, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titem.DoRepair(this.conditionLost);\r\n\t\tif (this.successEffect.isValid)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdd",
      "HookName": "OnRfListenerAdd",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemove",
      "HookName": "OnRfListenerRemove",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdd",
      "HookName": "OnRfBroadcasterAdd",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemove",
      "HookName": "OnRfBroadcasterRemove",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdded",
      "HookName": "OnRfBroadcasterAdded",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemoved",
      "HookName": "OnRfListenerRemoved",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdded",
      "HookName": "OnRfListenerAdded",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> listenList = global::RFManager.GetListenList(frequency);\r\n\tif (listenList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemoved",
      "HookName": "OnRfBroadcasterRemoved",
      "HookParameters": {
        "IRFObject": "obj",
        "int": "frequency"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::IRFObject> broadcasterList = global::RFManager.GetBroadcasterList(frequency);\r\n\tif (broadcasterList.Contains(obj))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Broadcaster]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "RFBroadcaster": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, this.IsPowered());\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Broadcaster]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "RFBroadcaster": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, this.IsPowered());\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Receiver]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "RFReceiver": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Receiver]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "RFReceiver": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Detonator]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "Detonator": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::RFManager.IsReserved(num))\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, base.IsOn());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Detonator]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "Detonator": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (global::RFManager.IsReserved(num))\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, base.IsOn());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [PagerEntity]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "PagerEntity": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextChangeTime = Time.time + 2f;\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [PagerEntity]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "PagerEntity": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextChangeTime = Time.time + 2f;\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoveDying",
      "HookName": "OnRemoveDying",
      "HookParameters": {
        "GrowableEntity": "this",
        "BasePlayer": "receiver"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RemoveDying",
        "ReturnType": "void",
        "Arguments": {
          "receiver": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.Properties.removeDyingItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRemoveDying\", this, receiver) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.Properties.removeDyingEffect.isValid)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSleepingBagDestroy",
      "HookName": "OnSleepingBagDestroy",
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::SleepingBag sleepingBag2 = global::SleepingBag.FindForPlayer(player.userID, sleepingBag, false);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSleepingBagDestroy\", sleepingBag2, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (sleepingBag2.canBePublic)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagDestroyed",
      "HookName": "OnSleepingBagDestroyed",
      "HookParameters": {
        "SleepingBag": "sleepingBag2",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::SleepingBag sleepingBag2 = global::SleepingBag.FindForPlayer(player.userID, sleepingBag, false);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSleepingBagDestroy\", sleepingBag2, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (sleepingBag2.canBePublic)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnConstructionPlace",
      "HookName": "OnConstructionPlace",
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoPlacement",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "placement": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfloat num2 = (buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth;\r\n\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\r\n\t\tbaseCombatEntity.InitializeHealth(num2 * num, num2);\r\n\t}\r\n\tif (Interface.CallHook(\"OnConstructionPlace\", baseEntity, component, placement, ownerPlayer) != null)\r\n\t{\r\n\t\tif (baseEntity.IsValid())\r\n\t\t{\r\n\t\t\tbaseEntity.KillMessage();\r\n\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAnalysisComplete",
      "HookName": "OnAnalysisComplete",
      "HookParameters": {
        "SurveyCrater": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCrater",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AnalysisComplete",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server]\r\npublic void AnalysisComplete(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tInterface.CallHook(\"OnAnalysisComplete\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkInput",
      "HookName": "OnBookmarkInput",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "InputState": "inputState"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void PlayerServerInput(global::InputState inputState, global::BasePlayer player)\r\n{\r\n\tbase.PlayerServerInput(inputState, player);\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved2) && this.currentlyControllingEnt.IsValid(true))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkInput\", this, player, inputState) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.currentlyControllingEnt.Get(true).GetComponent<global::IRemoteControllable>().UserInput(inputState, new global::CameraViewerId(player.userID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerInitialized",
      "HookName": "IOnServerInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "OpenConnection",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::EACServer.DoStartup();\r\n\tbase.InvokeRepeating(\"DoTick\", 1f, 1f / (float)ConVar.Server.tickrate);\r\n\tbase.InvokeRepeating(\"DoHeartbeat\", 1f, 1f);\r\n\tthis.runFrameUpdate = true;\r\n\tConsoleSystem.OnReplicatedVarChanged += new System.Action<string, string>(global::ServerMgr.OnReplicatedVarChanged);\r\n\tInterface.CallHook(\"IOnServerInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [AutoTurret]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "AutoTurret": "this",
        "UInt64": "playerID"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !this.booting && this.IsPowered() && !this.PeacekeeperMode();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [PoweredRemoteControl]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "PoweredRemoteControlEntity": "this",
        "UInt64": "playerID"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.IsPowered() || this.IsStatic();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [RemoteControlEntity]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "RemoteControlEntity": "this",
        "UInt64": "playerID"
      },
      "ReturnBehavior": 1,
      "TargetType": "RemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [ContainerIOEntity]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "BasePlayer": "player",
        "ContainerIOEntity": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [DroppedItemContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "BasePlayer": "player",
        "DroppedItemContainer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tif (this.inventory == null || this.inventory.itemList == null || this.inventory.itemList.Count == 0)\r\n\t{\r\n\t\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t\treturn;\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemLock",
      "HookName": "OnItemLock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.HasFlag(global::Item.Flag.IsLocked) == bNewState)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetFlag(global::Item.Flag.IsLocked, bNewState);\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemUnlock",
      "HookName": "OnItemUnlock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.HasFlag(global::Item.Flag.IsLocked) == bNewState)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetFlag(global::Item.Flag.IsLocked, bNewState);\r\n\tthis.MarkDirty();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretRotate",
      "HookName": "OnTurretRotate",
      "HookParameters": {
        "AutoTurret": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "FlipAim",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsOnline() || !this.IsAuthed(rpc.player) || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretRotate\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange",
      "HookName": "OnCounterTargetChange",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint OxideGen_0 = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnCounterTargetChange\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange [patch]",
      "HookName": "OnCounterTargetChange [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint OxideGen_0 = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnCounterTargetChange\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle",
      "HookName": "OnCounterModeToggle",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool OxideGen_0 = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnCounterModeToggle\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle [patch]",
      "HookName": "OnCounterModeToggle [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool OxideGen_0 = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnCounterModeToggle\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [ElectricSwitch]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "ElectricSwitch": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [FuelGenerator]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "FuelGenerator": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStart [MotorRowboat]",
      "HookName": "OnEngineStart",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.fuelSystem.HasFuel(true))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer OxideGen_0 = this.GetDriver();\r\n\tif (wantsOn && Interface.CallHook(\"OnEngineStart\", this, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, wantsOn, false, true);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStarted [MotorRowboat]",
      "HookName": "OnEngineStarted",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.fuelSystem.HasFuel(true))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer OxideGen_0 = this.GetDriver();\r\n\tif (wantsOn && Interface.CallHook(\"OnEngineStart\", this, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, wantsOn, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefresh",
      "HookName": "OnEngineStatsRefresh",
      "HookParameters": {
        "VehicleModuleEngine": "this",
        "EngineStorage": "engineStorage"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (Interface.CallHook(\"OnEngineStatsRefresh\", this, engineStorage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (engineStorage == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefreshed",
      "HookName": "OnEngineStatsRefreshed",
      "HookParameters": {
        "VehicleModuleEngine": "this",
        "EngineStorage": "engineStorage"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (Interface.CallHook(\"OnEngineStatsRefresh\", this, engineStorage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (engineStorage == null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelect",
      "HookName": "OnVehicleModuleSelect",
      "HookParameters": {
        "Item": "player",
        "ModularCarGarage": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelected",
      "HookName": "OnVehicleModuleSelected",
      "HookParameters": {
        "Item": "player",
        "ModularCarGarage": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnVehicleModuleSelectedFix [patch]",
      "HookName": "OnVehicleModuleSelectedFix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleDeselected",
      "HookName": "OnVehicleModuleDeselected",
      "HookParameters": {
        "ModularCarGarage": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_DeselectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (player.inventory.loot.RemoveContainerAt(3))\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n\tInterface.CallHook(\"OnVehicleModuleDeselected\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationRespond",
      "HookName": "OnNpcConversationRespond",
      "HookParameters": {
        "NPCTalking": "this",
        "BasePlayer": "player",
        "ConversationData": "player",
        "ResponseNode": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationResponded",
      "HookName": "OnNpcConversationResponded",
      "HookParameters": {
        "NPCTalking": "this",
        "BasePlayer": "player",
        "ConversationData": "player",
        "ResponseNode": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcConversationResponded [patch]",
      "HookName": "OnNpcConversationResponded [patch]",
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockableCheck",
      "HookName": "OnVehicleLockableCheck",
      "HookParameters": {
        "ModularCarCodeLock": "this"
      },
      "ReturnBehavior": 4,
      "TargetType": "ModularCarCodeLock",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanHaveALock",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanHaveALock()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleLockableCheck\", this);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn !this.owner.IsDead() && this.owner.HasDriverMountPoints();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnElevatorButtonPress",
      "HookName": "OnElevatorButtonPress",
      "ReturnBehavior": 0,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "Server_RaiseLowerFloor",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Elevator.Direction direction = (global::Elevator.Direction)msg.read.Int32();\r\n\tbool flag = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnElevatorButtonPress\", this, msg.player, direction, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag((direction == global::Elevator.Direction.Up) ? global::BaseEntity.Flags.Reserved1 : global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\tthis.owner.Server_RaiseLowerElevator(direction, flag);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggle",
      "HookName": "OnHotAirBalloonToggle",
      "HookParameters": {
        "HotAirBalloon": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [on]",
      "HookName": "OnHotAirBalloonToggled",
      "HookParameters": {
        "HotAirBalloon": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [off]",
      "HookName": "OnHotAirBalloonToggled",
      "HookParameters": {
        "HotAirBalloon": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineLoadoutRefresh",
      "HookName": "OnEngineLoadoutRefresh",
      "HookParameters": {
        "EngineStorage": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.Modular.EngineStorage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshLoadoutData",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RefreshLoadoutData()\r\n{\r\n\tif (Interface.CallHook(\"OnEngineLoadoutRefresh\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool arg_4F_1;\r\n\tif (base.inventory.IsFull())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnReactiveTargetReset",
      "HookName": "OnReactiveTargetReset",
      "HookParameters": {
        "ReactiveTarget": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ReactiveTarget",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ResetTarget",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tbase.CancelInvoke(new System.Action(this.ResetTarget));\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tthis.knockdownHealth = 100f;\r\n\tthis.SendPowerBurst();\r\n\tInterface.CallHook(\"OnReactiveTargetReset\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStarted",
      "HookName": "OnExperimentStarted",
      "HookParameters": {
        "Workbench": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentStart\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnd",
      "HookName": "OnExperimentEnd",
      "HookParameters": {
        "Workbench": "this"
      },
      "ReturnBehavior": 4,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint scrapForExperiment = this.GetScrapForExperiment();\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tDebug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && this.pendingBlueprint != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnded",
      "HookName": "OnExperimentEnded",
      "HookParameters": {
        "Workbench": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tint scrapForExperiment = this.GetScrapForExperiment();\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tDebug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && this.pendingBlueprint != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleMove",
      "HookName": "OnVehicleModuleMove",
      "HookParameters": {
        "BaseVehicleModule": "moduleForItem",
        "BaseModularVehicle": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseModularVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanMoveFrom",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "item": "Item"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseVehicleModule moduleForItem = this.GetModuleForItem(item);\r\n\tif (!(moduleForItem != null))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleModuleMove\", moduleForItem, this, player);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn moduleForItem.CanBeMovedNow();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [BaseMountable]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [ModularCarSeat]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "BasePlayer": "player",
        "ModularCarSeat": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarSeat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.associatedSeatingModule.DoorsAreLockable)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaim",
      "HookName": "OnRidableAnimalClaim",
      "HookParameters": {
        "BaseRidableAnimal": "this",
        "BasePlayer": "player",
        "Item": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRidableAnimal",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.GetPurchaseToken(player, tokenItemID);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRidableAnimalClaim\", this, player, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, true);\r\n\tthis.OnClaimedWithToken(item);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaimed",
      "HookName": "OnRidableAnimalClaimed",
      "HookParameters": {
        "BaseRidableAnimal": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseRidableAnimal",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::Item item = this.GetPurchaseToken(player, tokenItemID);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRidableAnimalClaim\", this, player, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, true);\r\n\tthis.OnClaimedWithToken(item);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupEntered",
      "HookName": "OnNetworkGroupEntered",
      "HookParameters": {
        "BaseNetworkable": "this",
        "Group": "group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupEnter",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupEnter(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupEntered\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupLeft",
      "HookName": "OnNetworkGroupLeft",
      "HookParameters": {
        "BaseNetworkable": "this",
        "Group": "group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupLeave",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupLeave(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupLeft\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStart",
      "HookName": "OnDemoRecordingStart",
      "HookParameters": {
        "string": "text",
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Format(\"demos/{0}/{1:yyyy-MM-dd-hhmmss}.dem\", this.UserIDString, System.DateTime.Now);\r\n\tif (Interface.CallHook(\"OnDemoRecordingStart\", text, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording started: \" + text);\r\n\tthis.net.connection.StartRecording(text, new ConVar.Demo.Header\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStarted",
      "HookName": "OnDemoRecordingStarted",
      "HookParameters": {
        "string": "text",
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Format(\"demos/{0}/{1:yyyy-MM-dd-hhmmss}.dem\", this.UserIDString, System.DateTime.Now);\r\n\tif (Interface.CallHook(\"OnDemoRecordingStart\", text, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording started: \" + text);\r\n\tthis.net.connection.StartRecording(text, new ConVar.Demo.Header\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCook",
      "HookName": "OnOvenCook",
      "HookParameters": {
        "BaseOven": "this",
        "Item": "item"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Cook()\r\n{\r\n\tglobal::Item item = this.FindBurnable();\r\n\tif (Interface.CallHook(\"OnOvenCook\", this, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCooked",
      "HookName": "OnOvenCooked",
      "HookParameters": {
        "BaseOven": "this",
        "Item": "item",
        "BaseEntity": "item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Cook()\r\n{\r\n\tglobal::Item item = this.FindBurnable();\r\n\tif (Interface.CallHook(\"OnOvenCook\", this, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelAmountCheck",
      "HookName": "OnFuelAmountCheck",
      "HookParameters": {
        "EntityFuelSystem": "this",
        "Item": "fuelItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelAmount",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "public int GetFuelAmount()\r\n{\r\n\tglobal::Item fuelItem = this.GetFuelItem();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelAmountCheck\", this, fuelItem);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (fuelItem == null || fuelItem.amount < 1)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelItemCheck",
      "HookName": "OnFuelItemCheck",
      "HookParameters": {
        "EntityFuelSystem": "this",
        "StorageContainer": "fuelContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelItem",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public global::Item GetFuelItem()\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelItemCheck\", this, fuelContainer);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (fuelContainer == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelCheck",
      "HookName": "OnFuelCheck",
      "HookParameters": {
        "EntityFuelSystem": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "HasFuel",
        "ReturnType": "bool",
        "Arguments": {
          "forceCheck": "bool"
        }
      },
      "CodeAfterInjection": "public bool HasFuel(bool forceCheck = false)\r\n{\r\n\tif (Time.time > this.nextFuelCheckTime | forceCheck)\r\n\t{\r\n\t\tobject returnvar = Interface.CallHook(\"OnFuelCheck\", this);\r\n\t\tif (returnvar is bool)\r\n\t\t{\r\n\t\t\treturn (bool)returnvar;\r\n\t\t}\r\n\t\tthis.cachedHasFuel = ((float)this.GetFuelAmount() > 0f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCheckFuel",
      "HookName": "CanCheckFuel",
      "HookParameters": {
        "EntityFuelSystem": "this",
        "StorageContainer": "fuelContainer",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "IsInFuelInteractionRange",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool IsInFuelInteractionRange(global::BasePlayer player)\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"CanCheckFuel\", this, fuelContainer, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (fuelContainer != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNode",
      "HookName": "CanUnlockTechTreeNode",
      "HookParameters": {
        "BasePlayer": "player",
        "NodeInstance": "node",
        "TechTreeData": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerCanUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerCanUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNode\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerHasPathForUnlock(player, node) && !this.HasPlayerUnlocked(player, node);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNodePath",
      "HookName": "CanUnlockTechTreeNodePath",
      "HookParameters": {
        "BasePlayer": "player",
        "NodeInstance": "node",
        "TechTreeData": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerHasPathForUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerHasPathForUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNodePath\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::TechTreeData.NodeInstance entryNode = this.GetEntryNode();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnIORefCleared [patch]",
      "HookName": "OnIORefCleared [patch]",
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnIORefCleared",
      "HookName": "OnIORefCleared",
      "HookParameters": {
        "IORef": "this",
        "IOEntity": "OxideGen_0"
      },
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlock",
      "HookName": "OnTechTreeNodeUnlock",
      "HookParameters": {
        "Workbench": "this",
        "NodeInstance": "player",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tDebug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTechTreeNodeUnlock\", this, byID, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num2 = global::ResearchTable.ScrapForResearch(byID.itemDef, global::ResearchTable.ResearchType.TechTree);\r\n\t\t\tint itemid = global::ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlocked",
      "HookName": "OnTechTreeNodeUnlocked",
      "HookParameters": {
        "Workbench": "this",
        "NodeInstance": "player",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tDebug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTechTreeNodeUnlock\", this, byID, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num2 = global::ResearchTable.ScrapForResearch(byID.itemDef, global::ResearchTable.ResearchType.TechTree);\r\n\t\t\tint itemid = global::ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanReceiveCall",
      "HookName": "CanReceiveCall",
      "HookParameters": {
        "PhoneController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "CanReceiveCall",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "private bool CanReceiveCall()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanReceiveCall\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (!this.RequirePower || this.IsPowered()) && (!this.RequireParent || base.baseEntity.HasParent());\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryNetworkUpdate",
      "HookName": "OnInventoryNetworkUpdate",
      "HookParameters": {
        "PlayerInventory": "this",
        "ItemContainer": "container",
        "UpdateItemContainer": "updateItemContainer",
        "Type": "type",
        "bool": "bSendInventoryToEveryone"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdatedInventory",
        "ReturnType": "void",
        "Arguments": {
          "type": "PlayerInventory/Type",
          "container": "ItemContainer",
          "bSendInventoryToEveryone": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tcontainer.dirty = false;\r\n\t\t\tupdateItemContainer.container = Pool.Get<System.Collections.Generic.List<ProtoBuf.ItemContainer>>();\r\n\t\t\tupdateItemContainer.container.Add(container.Save());\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnInventoryNetworkUpdate\", this, container, updateItemContainer, type, bSendInventoryToEveryone) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (bSendInventoryToEveryone)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [ItemDef]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "ItemDefinition": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "info": "ItemDefinition",
          "type": "ResearchTable/ResearchType"
        }
      },
      "CodeAfterInjection": "public static int ScrapForResearch(global::ItemDefinition info, global::ResearchTable.ResearchType type)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", info);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootNetworkUpdate",
      "HookName": "OnLootNetworkUpdate",
      "HookParameters": {
        "PlayerLoot": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tthis.isInvokingSendUpdate = false;\r\n\tif (!base.baseEntity.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLootNetworkUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindSpawnPoint",
      "HookName": "OnFindSpawnPoint",
      "HookParameters": {
        "BasePlayer": "forPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "FindSpawnPoint",
        "ReturnType": "BasePlayer/SpawnPoint",
        "Arguments": {
          "forPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public static global::BasePlayer.SpawnPoint FindSpawnPoint(global::BasePlayer forPlayer = null)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindSpawnPoint\", forPlayer);\r\n\tif (returnvar is global::BasePlayer.SpawnPoint)\r\n\t{\r\n\t\treturn (global::BasePlayer.SpawnPoint)returnvar;\r\n\t}\r\n\tbool flag = false;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [key]",
      "HookName": "CanLock",
      "HookParameters": {
        "BasePlayer": "player",
        "KeyLock": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Lock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(player))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationEnded",
      "HookName": "OnNpcConversationEnded",
      "HookParameters": {
        "NPCTalking": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "ForceEndConversation",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void ForceEndConversation(global::BasePlayer player)\r\n{\r\n\tbase.ClientRPCPlayer(null, player, \"Client_EndConversation\");\r\n\tInterface.CallHook(\"OnNpcConversationEnded\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationEnded",
      "HookName": "OnNpcConversationEnded",
      "HookParameters": {
        "NPCTalking": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_EndTalking",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void Server_EndTalking(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tthis.OnConversationEnded(msg.player);\r\n\tInterface.CallHook(\"OnNpcConversationEnded\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlStarted",
      "HookName": "OnBookmarkControlStarted",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "string": "player",
        "IRemoteControllable": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded",
      "HookName": "OnBookmarkControlEnded",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "ply",
        "BaseEntity": "baseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void StopControl(global::BasePlayer ply)\r\n{\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkControlEnd\", this, ply, baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.GetComponent<global::IRemoteControllable>().StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerAddModifiers",
      "HookName": "OnPlayerAddModifiers",
      "ReturnBehavior": 0,
      "TargetType": "ItemModConsume",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAction",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tplayer.metabolism.ApplyChange(current.type, current.amount * num3 * num4, current.time * num3 * num4);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (player.modifiers != null && Interface.CallHook(\"OnPlayerAddModifiers\", player, item, consumable) == null)\r\n\t{\r\n\t\tplayer.modifiers.Add(consumable.modifiers);\r\n\t}\r\n\tif (this.product != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoPlaneSignaled",
      "HookName": "OnCargoPlaneSignaled",
      "HookParameters": {
        "BaseEntity": "baseEntity",
        "SupplySignal": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tInterface.CallHook(\"OnCargoPlaneSignaled\", baseEntity, this);\r\n\tbase.Invoke(new System.Action(this.FinishUp), 210f);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCargoPlaneSignaled [Patch]",
      "HookName": "OnCargoPlaneSignaled [Patch]",
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tInterface.CallHook(\"OnCargoPlaneSignaled\", baseEntity, this);\r\n\tbase.Invoke(new System.Action(this.FinishUp), 210f);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropDropped",
      "HookName": "OnSupplyDropDropped",
      "HookParameters": {
        "BaseEntity": "num",
        "CargoPlane": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 1]",
      "HookName": "OnSupplyDropDropped [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 2]",
      "HookName": "OnSupplyDropDropped [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 3]",
      "HookName": "OnSupplyDropDropped [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (baseEntity)\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded [2]",
      "HookName": "OnBookmarkControlEnded",
      "HookParameters": {
        "ComputerStation": "this",
        "BasePlayer": "player",
        "IRemoteControllable": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBookmarkControlEnded [2] [patch]",
      "HookName": "OnBookmarkControlEnded [2] [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 1]",
      "HookName": "LimitNetworkingNoEffect [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "Effect/server",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public static void ImpactEffect(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnImpactEffectCreate\", info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.InitiatorPlayer && info.InitiatorPlayer.limitNetworking)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 2]",
      "HookName": "LimitNetworkingNoEffect [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::AntiHack.Log(player, global::AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\");\r\n\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnWeaponFired\", this, msg.player, component, projectileShoot);\r\n\tif (player.InGesture)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SignalBroadcast(global::BaseEntity.Signal.Attack, string.Empty, msg.connection);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 3]",
      "HookName": "LimitNetworkingNoEffect [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"IOnBasePlayerAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat health = base.health;\r\n\tif (this.InSafeZone() && !this.IsHostile() && info.Initiator != null && info.Initiator != this)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSubmit",
      "HookName": "OnItemSubmit",
      "HookParameters": {
        "Item": "slot",
        "Mailbox": "this",
        "BasePlayer": "fromPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SubmitInputItems",
        "ReturnType": "void",
        "Arguments": {
          "fromPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (slot != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnItemSubmit\", slot, this, fromPlayer) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.MoveItemToStorage(slot))\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnThreatLevelUpdate",
      "HookName": "OnThreatLevelUpdate",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EnsureUpdated",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tthis.lastUpdateTime = Time.realtimeSinceStartup;\r\n\tthis.cachedThreatLevel = 0f;\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnThreatLevelUpdate\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.inventory.containerWear.itemList.Count > 2)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurify",
      "HookName": "OnWaterPurify",
      "HookParameters": {
        "WaterPurifier": "this",
        "Single": "timeCooked"
      },
      "ReturnBehavior": 4,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterPurify\", this, timeCooked) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = timeCooked * ((float)this.waterToProcessPerMinute / 60f);\r\n\tthis.dirtyWaterProcssed += num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurified",
      "HookName": "OnWaterPurified",
      "HookParameters": {
        "WaterPurifier": "this",
        "Single": "timeCooked"
      },
      "ReturnBehavior": 0,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tif (slot != null && slot.amount >= slot.MaxStackable())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterPurify\", this, timeCooked) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = timeCooked * ((float)this.waterToProcessPerMinute / 60f);\r\n\tthis.dirtyWaterProcssed += num;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseGesture",
      "HookName": "CanUseGesture",
      "HookParameters": {
        "BasePlayer": "player",
        "GestureConfig": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "GestureConfig",
      "Category": "Player",
      "MethodData": {
        "MethodName": "IsOwnedBy",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool IsOwnedBy(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseGesture\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.forceUnlock)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnect",
      "HookName": "OnClientDisconnect",
      "HookParameters": {
        "Connection": "connection",
        "string": "text"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ReadDisconnectReason",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tstring text = packet.read.String(4096);\r\n\tstring text2 = packet.connection.ToString();\r\n\tif (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))\r\n\t{\r\n\t\tInterface.CallHook(\"OnClientDisconnect\", packet.connection, text);\r\n\t\tDebugEx.Log(text2 + \" disconnecting: \" + text, StackTraceLogType.None);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRespawnInformationGiven",
      "HookName": "OnRespawnInformationGiven",
      "HookParameters": {
        "BasePlayer": "this",
        "RespawnInformation": "respawnInformation"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendRespawnOptions",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tspawnOptions.occupied = sleepingBag.IsOccupied();\r\n\t\t\trespawnInformation.spawnOptions.Add(spawnOptions);\r\n\t\t}\r\n\t\trespawnInformation.previousLife = this.previousLifeStory;\r\n\t\trespawnInformation.fadeIn = (this.previousLifeStory != null && (ulong)this.previousLifeStory.timeDied > (ulong)((long)(Epoch.Current - 5)));\r\n\t\tInterface.CallHook(\"OnRespawnInformationGiven\", this, respawnInformation);\r\n\t\tbase.ClientRPCPlayer<RespawnInformation>(null, this, \"OnRespawnInformation\", respawnInformation);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCentralizedBanCheck",
      "HookName": "OnCentralizedBanCheck",
      "ReturnBehavior": 0,
      "TargetType": "Auth_CentralizedBans/<Run>d__0",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "bool System.Collections.IEnumerator.MoveNext()\r\n{\r\n\tobject OxideGen_3 = Interface.CallHook(\"OnCentralizedBanCheck\", this.connection);\r\n\tif (OxideGen_3 != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tswitch (this.<>1__state)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientCommand",
      "HookName": "OnClientCommand",
      "HookParameters": {
        "Connection": "connection",
        "string": "text"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (packet.connection == null || !packet.connection.connected)\r\n\t{\r\n\t\tDebug.LogWarning(\"Client without connection tried to run command: \" + text);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnClientCommand\", packet.connection, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text, System.Array.Empty<object>());\r\n\tif (!string.IsNullOrEmpty(text2))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagValidCheck",
      "HookName": "OnSleepingBagValidCheck",
      "HookParameters": {
        "SleepingBag": "this",
        "ulong": "playerID",
        "bool": "ignoreTimers"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ValidForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong",
          "ignoreTimers": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnSleepingBagValidCheck\", this, playerID, ignoreTimers);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.deployerUserID == playerID && (ignoreTimers || this.unlockTime < Time.realtimeSinceStartup);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardAuthorize [ItemModDeployable]",
      "HookName": "OnCupboardAuthorize",
      "HookParameters": {
        "BuildingPrivlidge": "buildingPrivlidge",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModDeployable",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "OnDeployed",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tplayer.GiveAchievement(this.UnlockAchievement);\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivlidge;\r\n\tif ((buildingPrivlidge = (ent as global::BuildingPrivlidge)) != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnCupboardAuthorize\", buildingPrivlidge, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuildingPrivlidge.AddPlayer(player);\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "FixAIBrainTryThinkNRE [patch]",
      "HookName": "FixAIBrainTryThinkNRE [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseAnimalNPC",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "TryThink",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [AIBrainSenses]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "AIBrainSenses",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetNearest",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "entities": "System.Collections.Generic.List`1<BaseEntity>",
          "rangeFraction": "float"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tfloat num = float.PositiveInfinity;\r\n\tglobal::BaseEntity result = null;\r\n\tforeach (global::BaseEntity current in entities)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this.owner, current) == null)\r\n\t\t{\r\n\t\t\tfloat num2 = Vector3.Distance(current.transform.position, this.owner.transform.position);\r\n\t\t\tif (num2 <= rangeFraction * this.maxRange && num2 < num)\r\n\t\t\t{\r\n\t\t\t\tresult = current;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "ContinueTargetScan [patch]",
      "HookName": "ContinueTargetScan [patch]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingAcquaintances [patch]",
      "HookName": "LimitNetworkingAcquaintances [patch]",
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateAcquaintancesFor",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "deltaSeconds": "float"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnLiquidVesselFill",
      "HookName": "OnLiquidVesselFill",
      "HookParameters": {
        "BaseLiquidVessel": "this",
        "BasePlayer": "ownerPlayer",
        "LiquidContainer": "ownerPlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLiquidVessel",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "FillCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tfloat f = (Time.realtimeSinceStartup - this.lastFillTime) * this.fillMlPerSec;\r\n\tVector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);\r\n\tglobal::LiquidContainer facingLiquidContainer = this.GetFacingLiquidContainer();\r\n\tif (Interface.CallHook(\"OnLiquidVesselFill\", this, ownerPlayer, facingLiquidContainer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (facingLiquidContainer == null && this.CanFillFromWorld())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCCTVDirectionChange",
      "HookName": "OnCCTVDirectionChange",
      "HookParameters": {
        "CCTV_RC": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "CCTV_RC",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Server_SetDir",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!player.CanBuild() || !player.IsBuildingAuthed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCCTVDirectionChange\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 vector = Vector3Ex.Direction(player.eyes.position, this.yaw.transform.position);\r\n\tvector = base.transform.InverseTransformDirection(vector);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWound",
      "HookName": "OnPlayerWound",
      "HookParameters": {
        "BasePlayer": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "BecomeWounded",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWound\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = info != null && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Fall;\r\n\tif (this.IsCrawling())\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "IncapacitatedFalseRespawn [patch]",
      "HookName": "IncapacitatedFalseRespawn [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "RespawnAt",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "spawnPointEntity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.net != null)\r\n\t{\r\n\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRespawned\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "FixAIBrainThinkNRE [patch]",
      "HookName": "FixAIBrainThinkNRE [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseAIBrain",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Think",
        "ReturnType": "void",
        "Arguments": {
          "delta": "float"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnPlayerDismountFailed",
      "HookName": "OnPlayerDismountFailed",
      "HookParameters": {
        "BasePlayer": "player",
        "BaseMountable": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AttemptDismount(player);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAccessVendingMachine",
      "HookName": "CanAccessVendingMachine",
      "HookParameters": {
        "MarketTerminal": "this",
        "VendingMachine": "vendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "MarketTerminal",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "<GetDeliveryEligibleVendingMachines>g__IsEligible|24_0",
        "ReturnType": "bool",
        "Arguments": {
          "vendingMachine": "VendingMachine",
          "offset": "UnityEngine.Vector3",
          "n": "int"
        }
      },
      "CodeAfterInjection": "[System.Runtime.CompilerServices.CompilerGenerated]\r\nprivate bool <GetDeliveryEligibleVendingMachines>g__IsEligible|24_0(global::VendingMachine vendingMachine, Vector3 offset, int n)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAccessVendingMachine\", this.config, vendingMachine);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ConsumptionAmount",
        "ReturnType": "int",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": ".ctor",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnDecayHeal",
      "HookName": "OnDecayHeal",
      "HookParameters": {
        "DecayEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DecayTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnDecayHeal\", this) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num3 = num / this.decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\r\n\t\t\t\tthis.Heal(this.MaxHealth() * num3);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDecayDamage",
      "HookName": "OnDecayDamage",
      "HookParameters": {
        "DecayEntity": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DecayTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tif (this.upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnDecayHeal\", this) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num3 = num / this.decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\r\n\t\t\t\tthis.Heal(this.MaxHealth() * num3);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdate",
      "HookName": "OnWindmillUpdate",
      "HookParameters": {
        "ElectricWindmill": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void WindUpdate()\r\n{\r\n\tif (Interface.CallHook(\"OnWindmillUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.serverWindSpeed = this.GetWindSpeedScale();\r\n\tif (!this.AmIVisible())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdated",
      "HookName": "OnWindmillUpdated",
      "HookParameters": {
        "ElectricWindmill": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void WindUpdate()\r\n{\r\n\tif (Interface.CallHook(\"OnWindmillUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.serverWindSpeed = this.GetWindSpeedScale();\r\n\tif (!this.AmIVisible())\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanElevatorLiftMove",
      "HookName": "CanElevatorLiftMove",
      "HookParameters": {
        "ElevatorLift": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "CanMove",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanMove()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanElevatorLiftMove\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.VehicleTrigger.HasContents && this.VehicleTrigger.entityContents != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeRecycled",
      "HookName": "CanBeRecycled",
      "HookParameters": {
        "Item": "item",
        "Recycler": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanBeRecycled",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "private bool CanBeRecycled(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeRecycled\", item, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn item != null && item.info.Blueprint != null;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelLoss",
      "HookName": "OnBigWheelLoss",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tglobal::Item slot = current.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\t\tint amount = slot.amount;\r\n\t\t\t\tif (Interface.CallHook(\"OnBigWheelWin\", this, slot, current, num) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tslot.amount += slot.amount * num;\r\n\t\t\t\t\tslot.RemoveFromContainer();\r\n\t\t\t\t\tslot.MoveToContainer(current.inventory, 5, true, false, null, true);\r\n\t\t\t\t\tflag = true;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelWin",
      "HookName": "OnBigWheelWin",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tglobal::Item slot = current.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\t\tint amount = slot.amount;\r\n\t\t\t\tif (Interface.CallHook(\"OnBigWheelWin\", this, slot, current, num) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tslot.amount += slot.amount * num;\r\n\t\t\t\t\tslot.RemoveFromContainer();\r\n\t\t\t\t\tslot.MoveToContainer(current.inventory, 5, true, false, null, true);\r\n\t\t\t\t\tflag = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityPickedUp",
      "HookName": "OnEntityPickedUp",
      "HookParameters": {
        "BaseCombatEntity": "this",
        "Item": "createdItem",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnPickedUp",
        "ReturnType": "void",
        "Arguments": {
          "createdItem": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void OnPickedUp(global::Item createdItem, global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnEntityPickedUp\", this, createdItem, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestartInterrupt",
      "HookName": "OnServerRestartInterrupt",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<global::ServerMgr>.Instance.restartCoroutine != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnServerRestartInterrupt\") != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestart",
      "HookName": "OnServerRestart",
      "HookParameters": {
        "string": "strNotice",
        "int": "iSeconds"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<global::ServerMgr>.Instance.restartCoroutine != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnServerRestartInterrupt\") != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseHelicopter",
      "HookName": "CanUseHelicopter",
      "HookParameters": {
        "BasePlayer": "player",
        "CH47HelicopterAIController": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      },
      "CodeAfterInjection": "public override void AttemptMount(global::BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanUseHelicopter\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.IsNpc && !player.IsAdmin)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "AllowNpcNonAdminHeliUse [patch]",
      "HookName": "AllowNpcNonAdminHeliUse [patch]",
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      },
      "CodeAfterInjection": "public override void AttemptMount(global::BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanUseHelicopter\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.IsNpc && !player.IsAdmin)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWildlifeTrap",
      "HookName": "OnWildlifeTrap",
      "HookParameters": {
        "WildlifeTrap": "this",
        "TrappableWildlife": "trapped"
      },
      "ReturnBehavior": 1,
      "TargetType": "WildlifeTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "TrapWildlife",
        "ReturnType": "void",
        "Arguments": {
          "trapped": "TrappableWildlife"
        }
      },
      "CodeAfterInjection": "public void TrapWildlife(global::TrappableWildlife trapped)\r\n{\r\n\tif (Interface.CallHook(\"OnWildlifeTrap\", this, trapped) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = global::ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);\r\n\tif (!item.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingStopped",
      "HookName": "OnFishingStopped",
      "HookParameters": {
        "BaseFishingRod": "this",
        "FailReason": "reason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_Cancel",
        "ReturnType": "void",
        "Arguments": {
          "reason": "BaseFishingRod/FailReason"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tfishingBobber.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t\tthis.currentBobber.Set(null);\r\n\t}\r\n\tbase.ClientRPC<int>(null, \"Client_ResetLine\", (int)reason);\r\n\tInterface.CallHook(\"OnFishingStopped\", this, reason);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCastFishingRod",
      "HookName": "CanCastFishingRod",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.EvaluateFishingPosition(ref vector, ownerPlayer, out reason, out this.surfaceBody))\r\n\t{\r\n\t\tthis.FailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tobject OxideGen_7 = Interface.CallHook(\"CanCastFishingRod\", ownerPlayer, this, currentLure, vector);\r\n\tif (OxideGen_7 is bool && !(bool)OxideGen_7)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::FishingBobber component = base.gameManager.CreateEntity(this.FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, base.GetOwnerPlayer().ServerRotation, true).GetComponent<global::FishingBobber>();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCatchFish",
      "HookName": "CanCatchFish",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL);\r\n\t\t\tobject OxideGen_14 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_14 is bool && !(bool)OxideGen_14)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingRodCast",
      "HookName": "OnFishingRodCast",
      "HookParameters": {
        "BaseFishingRod": "this",
        "BasePlayer": "vector",
        "Item": "vector"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.EvaluateFishingPosition(ref vector, ownerPlayer, out reason, out this.surfaceBody))\r\n\t{\r\n\t\tthis.FailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tobject OxideGen_7 = Interface.CallHook(\"CanCastFishingRod\", ownerPlayer, this, currentLure, vector);\r\n\tif (OxideGen_7 is bool && !(bool)OxideGen_7)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::FishingBobber component = base.gameManager.CreateEntity(this.FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, base.GetOwnerPlayer().ServerRotation, true).GetComponent<global::FishingBobber>();\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFishCatch",
      "HookName": "OnFishCatch",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL);\r\n\t\t\tobject OxideGen_14 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_14 is bool && !(bool)OxideGen_14)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDrink",
      "HookName": "OnPlayerDrink",
      "HookParameters": {
        "BasePlayer": "player",
        "LiquidContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SVDrink",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!rpc.player.metabolism.CanConsume())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDrink\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (global::Item current in base.inventory.itemList)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPurchaseItem",
      "HookName": "CanPurchaseItem",
      "HookParameters": {
        "BasePlayer": "buyer",
        "Item": "<>c__DisplayClass36_",
        "Action`2": "onItemPurchased",
        "VendingMachine": "this",
        "ItemContainer": "targetContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "DoTransaction",
        "ReturnType": "bool",
        "Arguments": {
          "buyer": "BasePlayer",
          "sellOrderId": "int",
          "numberOfTransactions": "int",
          "targetContainer": "ItemContainer",
          "onCurrencyRemoved": "System.Action`2<BasePlayer,Item>",
          "onItemPurchased": "System.Action`2<BasePlayer,Item>",
          "droneMarketTerminal": "MarketTerminal"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVendingTransaction\", this, buyer, sellOrderId, numberOfTransactions, targetContainer);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[sellOrderId];\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [NPCTalking]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "InvisibleVendingMachine": "vendingMachine",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::InvisibleVendingMachine vendingMachine = base.GetVendingMachine();\r\n\t\tif (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [FuseBox]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "BasePlayer": "player",
        "ItemBasedFlowRestrictor": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemBasedFlowRestrictor",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssign",
      "HookName": "OnTurretAssign",
      "HookParameters": {
        "AutoTurret": "this",
        "ulong": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL || this.IsAuthed(num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAssign\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring username = global::BasePlayer.SanitizePlayerNameString(msg.read.String(256), num);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssigned",
      "HookName": "OnTurretAssigned",
      "HookParameters": {
        "AutoTurret": "this",
        "ulong": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL || this.IsAuthed(num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAssign\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring username = global::BasePlayer.SanitizePlayerNameString(msg.read.String(256), num);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionFailed",
      "HookName": "OnMissionFailed",
      "HookParameters": {
        "BaseMission": "this",
        "MissionInstance": "instance",
        "BasePlayer": "assignee",
        "MissionFailReason": "failReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionFailed",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer",
          "failReason": "BaseMission/MissionFailReason"
        }
      },
      "CodeAfterInjection": "...\r\n\tglobal::BaseMission.DoMissionEffect(this.failedEffect.resourcePath, assignee);\r\n\tFacepunch.Rust.Analytics.Server.MissionFailed(this, failReason);\r\n\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, new global::BaseMission.MissionFailReason?(failReason));\r\n\tinstance.status = global::BaseMission.MissionStatus.Failed;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionFailed\", this, instance, assignee, failReason);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionSucceeded",
      "HookName": "OnMissionSucceeded",
      "HookParameters": {
        "BaseMission": "this",
        "MissionInstance": "instance",
        "BasePlayer": "assignee"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionSuccess",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionSuccess(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tinstance.status = global::BaseMission.MissionStatus.Accomplished;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tthis.MissionComplete(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionSucceeded\", this, instance, assignee);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStart",
      "HookName": "OnMissionStart",
      "HookParameters": {
        "BaseMission": "this",
        "MissionInstance": "instance",
        "BasePlayer": "assignee"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionStart(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tif (Interface.CallHook(\"OnMissionStart\", this, instance, assignee) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetupRewards(instance, assignee);\r\n\tthis.SetupPositions(instance, assignee);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignMission",
      "HookName": "CanAssignMission",
      "HookParameters": {
        "BasePlayer": "assignee",
        "BaseMission": "mission",
        "IMissionProvider": "provider"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAssignMission\", assignee, mission, provider);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BaseMission.MissionInstance missionInstance = Pool.Get<global::BaseMission.MissionInstance>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionAssigned",
      "HookName": "OnMissionAssigned",
      "HookParameters": {
        "BaseMission": "mission",
        "IMissionProvider": "provider",
        "BasePlayer": "assignee"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAssignMission\", assignee, mission, provider);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BaseMission.MissionInstance missionInstance = Pool.Get<global::BaseMission.MissionInstance>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStarted",
      "HookName": "OnMissionStarted",
      "HookParameters": {
        "BaseMission": "this",
        "MissionInstance": "instance",
        "BasePlayer": "assignee"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionStart(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tif (Interface.CallHook(\"OnMissionStart\", this, instance, assignee) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetupRewards(instance, assignee);\r\n\tthis.SetupPositions(instance, assignee);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [CarvablePumpkin]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "BasePlayer": "player",
        "CarvablePumpkin": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "CarvablePumpkin",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameExplosion",
      "HookName": "OnFlameExplosion",
      "HookParameters": {
        "FlameExplosive": "this",
        "Collider": "position"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameExplode",
        "ReturnType": "void",
        "Arguments": {
          "surfaceNormal": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tfloat num2 = (float)num / this.numToCreate;\r\n\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(this.spreadAngle * this.spreadCurve.Evaluate(num2), surfaceNormal, true);\r\n\t\t\tbaseEntity.transform.SetPositionAndRotation(position, Quaternion.LookRotation(modifiedAimConeDirection));\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnFlameExplosion\", this, component);\r\n\t\t\tVector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(this.minVelocity, this.maxVelocity) * this.velocityCurve.Evaluate(num2 * UnityEngine.Random.Range(1f, 1.1f));\r\n\t\t\tglobal::FireBall component2 = baseEntity.GetComponent<global::FireBall>();\r\n\t\t\tif (component2 != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent2.SetDelayedVelocity(vector);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEyePosValidate",
      "HookName": "OnEyePosValidate",
      "HookParameters": {
        "AttackEntity": "this",
        "BasePlayer": "player",
        "Vector3": "eyePos"
      },
      "ReturnBehavior": 1,
      "TargetType": "AttackEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ValidateEyePos",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "eyePos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "protected bool ValidateEyePos(global::BasePlayer player, Vector3 eyePos)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEyePosValidate\", this, player, eyePos);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tbool flag = true;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnImpactEffectCreate",
      "HookName": "OnImpactEffectCreate",
      "HookParameters": {
        "HitInfo": "info"
      },
      "ReturnBehavior": 4,
      "TargetType": "Effect/server",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public static void ImpactEffect(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnImpactEffectCreate\", info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.InitiatorPlayer && info.InitiatorPlayer.limitNetworking)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTargetScan",
      "HookName": "OnSamSiteTargetScan",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tthis.<TargetScan>g__AddTargetSet|55_0(list, 1048576, global::SamSite.targetTypeMissile.scanRadius);\r\n\tglobal::SamSite.ISamSiteTarget samSiteTarget = null;\r\n\tforeach (global::SamSite.ISamSiteTarget current in list)\r\n\t{\r\n\t\tif (!current.isClient && current.CenterPoint().y >= this.eyePoint.transform.position.y && current.IsVisible(this.eyePoint.transform.position, current.SAMTargetType.scanRadius * 2f) && current.IsValidSAMTarget(this.staticRespawn) && Interface.CallHook(\"OnSamSiteTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tsamSiteTarget = current;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUnwrap",
      "HookName": "OnItemUnwrap",
      "HookParameters": {
        "Item": "item",
        "BasePlayer": "player",
        "ItemModUnwrap": "this"
      },
      "ReturnBehavior": 4,
      "TargetType": "ItemModUnwrap",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tif (item.amount <= 0)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemUnwrap\", item, player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titem.UseItem(1);\r\n\t\tint num = UnityEngine.Random.Range(this.minTries, this.maxTries + 1);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSendModelState",
      "HookName": "OnSendModelState",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendModelState",
        "ReturnType": "void",
        "Arguments": {
          "force": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.modelState.sleeping = this.IsSleeping();\r\n\tthis.modelState.mounted = this.isMounted;\r\n\tthis.modelState.relaxed = this.IsRelaxed();\r\n\tthis.modelState.onPhone = (this.HasActiveTelephone && !this.activeTelephone.IsMobile);\r\n\tthis.modelState.crawling = this.IsCrawling();\r\n\tif (base.limitNetworking || Interface.CallHook(\"OnSendModelState\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC<ModelState>(null, \"OnModelState\", this.modelState);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [FrankensteinPet]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "FrankensteinPet": "this",
        "NPCPlayerCorpse": "timeWarning"
      },
      "ReturnBehavior": 1,
      "TargetType": "FrankensteinPet",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\tfor (int i = 0; i < containers.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t}\r\n\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\tif (returnvar is global::BaseCorpse)\r\n\t\t{\r\n\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t}\r\n\t\tresult = nPCPlayerCorpse;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [ScarecrowNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "ScarecrowNPC": "this",
        "string": "timeWarning"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScarecrowNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, text);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate [GingerbreadNPC]",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "GingerbreadNPC": "this",
        "NPCPlayerCorpse": "timeWarning"
      },
      "ReturnBehavior": 1,
      "TargetType": "GingerbreadNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\t\t{\r\n\t\t\t\tcontainers[i].Clear();\r\n\t\t\t}\r\n\t\t\tif (this.LootSpawnSlots.Length != 0)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tglobal::LootContainer.LootSpawnSlot[] lootSpawnSlots = this.LootSpawnSlots;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [HumanNPC]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetBestTarget",
        "ReturnType": "BaseEntity",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tglobal::BaseEntity result = null;\r\n\tfloat num = -1f;\r\n\tforeach (global::BaseEntity current in this.Brain.Senses.Players)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tfloat value = Vector3.Distance(current.transform.position, base.transform.position);\r\n\t\t\tfloat num2 = 1f - Mathf.InverseLerp(1f, this.Brain.SenseRange, value);\r\n\t\t\tfloat value2 = Vector3.Dot((current.transform.position - this.eyes.position).normalized, this.eyes.BodyForward());\r\n\t\t\tnum2 += Mathf.InverseLerp(this.Brain.VisionCone, 1f, value2) / 2f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasLootDistribute",
      "HookName": "OnXmasLootDistribute",
      "HookParameters": {
        "XMasRefill": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "ServerInit",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tthis.goodKids = ((global::BasePlayer.activePlayerList != null) ? new System.Collections.Generic.List<global::BasePlayer>(global::BasePlayer.activePlayerList) : new System.Collections.Generic.List<global::BasePlayer>());\r\n\tthis.stockings = ((global::Stocking.stockings != null) ? new System.Collections.Generic.List<global::Stocking>(global::Stocking.stockings.Values) : new System.Collections.Generic.List<global::Stocking>());\r\n\tbase.Invoke(new System.Action(this.RemoveMe), 60f);\r\n\tif (Interface.CallHook(\"OnXmasLootDistribute\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new System.Action(this.DistributeLoot), 3f, 0.02f);\r\n\tbase.Invoke(new System.Action(this.SendBells), 0.5f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasStockingFill",
      "HookName": "OnXmasStockingFill",
      "HookParameters": {
        "Stocking": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Stocking",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEmpty())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnXmasStockingFill\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.SpawnLoot();\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnXmasGiftsDistribute",
      "HookName": "OnXmasGiftsDistribute",
      "ReturnBehavior": 0,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "DistributeGiftsForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool DistributeGiftsForPlayer(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnXmasGiftsDistribute\", this, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = this.GiftsPerPlayer();\r\n\tint num2 = this.GiftSpawnAttempts();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcThink",
      "HookName": "OnBradleyApcThink",
      "HookParameters": {
        "BradleyAPC": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DoSimpleAI",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved5, TOD_Sky.Instance.IsNight, false, true);\r\n\tif (Interface.CallHook(\"OnBradleyApcThink\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.DoAI)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainCreate",
      "HookName": "OnTerrainCreate",
      "HookParameters": {
        "TerrainGenerator": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "TerrainGenerator",
      "Category": "World",
      "MethodData": {
        "MethodName": "CreateTerrain",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "heightmapResolution": "int",
          "alphamapResolution": "int"
        }
      },
      "CodeAfterInjection": "public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)\r\n{\r\n\tInterface.CallHook(\"OnTerrainCreate\", this);\r\n\tTerrain component = Terrain.CreateTerrainGameObject(new TerrainData\r\n\t{\r\n\t\tbaseMapResolution = global::TerrainGenerator.GetBaseMapRes(),\r\n\t\theightmapResolution = heightmapResolution,\r\n\t\talphamapResolution = alphamapResolution,\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnded",
      "HookName": "OnPlayerSleepEnded",
      "HookParameters": {
        "BasePlayer": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSleepEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Sleeping, false);\r\n\tthis.sleepStartTime = -1f;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequest",
      "HookName": "OnExcavatorSuppliesRequest",
      "HookParameters": {
        "ExcavatorSignalComputer": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(5uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RequestSupplies(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved7) && this.IsPowered() && this.chargePower >= global::ExcavatorSignalComputer.chargeNeededForSupplies)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnExcavatorSuppliesRequest\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.supplyPlanePrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequested",
      "HookName": "OnExcavatorSuppliesRequested",
      "HookParameters": {
        "ExcavatorSignalComputer": "this",
        "BasePlayer": "player",
        "BaseEntity": "baseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(5uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RequestSupplies(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved7) && this.IsPowered() && this.chargePower >= global::ExcavatorSignalComputer.chargeNeededForSupplies)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnExcavatorSuppliesRequest\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.supplyPlanePrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDesignFirework",
      "HookName": "CanDesignFirework",
      "HookParameters": {
        "BasePlayer": "player",
        "PatternFirework": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "PlayerCanModify",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (player == null || !player.CanInteract())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanDesignFirework\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivilege = this.GetBuildingPrivilege();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkStarted",
      "HookName": "OnFireworkStarted",
      "HookParameters": {
        "BaseFirework": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "Begin",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void Begin()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkStarted\", this);\r\n\tbase.Invoke(new System.Action(this.OnExhausted), this.activityLength);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkExhausted",
      "HookName": "OnFireworkExhausted",
      "HookParameters": {
        "BaseFirework": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnExhausted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, true, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, false);\r\n\tbase.EnableGlobalBroadcast(false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkExhausted\", this);\r\n\tbase.Invoke(new System.Action(this.Cleanup), this.corpseDuration);\r\n\tglobal::BaseFirework._activeFireworks.Remove(this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDamage",
      "HookName": "OnFireworkDamage",
      "HookParameters": {
        "BaseFirework": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n\tbase.OnAttacked(info);\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnFireworkDamage\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.damageTypes.Has(Rust.DamageType.Heat))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChange",
      "HookName": "OnFireworkDesignChange",
      "HookParameters": {
        "PatternFirework": "this",
        "Design": "design",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (Interface.CallHook(\"OnFireworkDesignChange\", this, design, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (((design != null) ? design.stars : null) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChanged",
      "HookName": "OnFireworkDesignChanged",
      "HookParameters": {
        "PatternFirework": "this",
        "Design": "design",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (!this.PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\r\n\tif (Interface.CallHook(\"OnFireworkDesignChange\", this, design, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (((design != null) ? design.stars : null) != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInformationUpdated",
      "HookName": "OnServerInformationUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateServerInformation",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tSteamServer.SetKey(\"fps\", global::Performance.report.frameRate.ToString());\r\n\t\tSteamServer.SetKey(\"fps_avg\", global::Performance.report.frameRateAverage.ToString(\"0.00\"));\r\n\t\tSteamServer.SetKey(\"ent_cnt\", global::BaseNetworkable.serverEntities.Count.ToString());\r\n\t\tSteamServer.SetKey(\"build\", BuildInfo.Current.Scm.ChangeId);\r\n\t}\r\n\tInterface.CallHook(\"OnServerInformationUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [CarvablePumpkin]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "CarvablePumpkin": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "CarvablePumpkin",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t}\r\n\t\tthis.textureIDs[num] = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskin",
      "HookName": "OnEntityReskin",
      "HookParameters": {
        "BaseEntity": "<>c__DisplayClass29_",
        "Skin": "<>c__DisplayClass29_",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemDefinition itemDefinition2 = null;\r\n\t\tulong skinID = global::ItemDefinition.FindSkin(itemDefinition.itemid, <>c__DisplayClass29_.targetSkin);\r\n\t\tglobal::ItemSkinDirectory.Skin skin = itemDefinition.skins.FirstOrDefault((global::ItemSkinDirectory.Skin x) => x.id == <>c__DisplayClass29_.targetSkin);\r\n\t\tif (Interface.CallHook(\"OnEntityReskin\", baseEntity, skin, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemSkin itemSkin;\r\n\t\tif (skin.invItem != null && (itemSkin = (skin.invItem as global::ItemSkin)) != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskinned",
      "HookName": "OnEntityReskinned",
      "HookParameters": {
        "BaseEntity": "<>c__DisplayClass29_",
        "Skin": "<>c__DisplayClass29_",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemDefinition itemDefinition2 = null;\r\n\t\tulong skinID = global::ItemDefinition.FindSkin(itemDefinition.itemid, <>c__DisplayClass29_.targetSkin);\r\n\t\tglobal::ItemSkinDirectory.Skin skin = itemDefinition.skins.FirstOrDefault((global::ItemSkinDirectory.Skin x) => x.id == <>c__DisplayClass29_.targetSkin);\r\n\t\tif (Interface.CallHook(\"OnEntityReskin\", baseEntity, skin, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ItemSkin itemSkin;\r\n\t\tif (skin.invItem != null && (itemSkin = (skin.invItem as global::ItemSkin)) != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemStacked [2]",
      "HookName": "OnItemStacked",
      "HookParameters": {
        "IItemContainerEntity": "timeWarning",
        "Item": "this",
        "ItemContainer": "newcontainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveToContainer",
        "ReturnType": "bool",
        "Arguments": {
          "newcontainer": "ItemContainer",
          "iTargetPos": "int",
          "allowStack": "bool",
          "ignoreStackLimit": "bool",
          "sourcePlayer": "BasePlayer",
          "allowSwap": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, this.amount);\r\n\t\t\t\t\t\tslot2.amount += num2;\r\n\t\t\t\t\t\tthis.amount -= num2;\r\n\t\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\t\tthis.MarkDirty();\r\n\t\t\t\t\t\tInterface.CallHook(\"OnItemStacked\", slot2, this, newcontainer, num2);\r\n\t\t\t\t\t\tif (this.amount <= 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthis.RemoveFromWorld();\r\n\t\t\t\t\t\t\tthis.RemoveFromContainer();\r\n\t\t\t\t\t\t\tthis.Remove(0f);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionDequeue",
      "HookName": "OnConnectionDequeue",
      "HookParameters": {
        "Connection": "connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "RemoveConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "public void RemoveConnection(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionDequeue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.queue.Remove(connection))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionQueue",
      "HookName": "OnConnectionQueue",
      "HookParameters": {
        "Connection": "connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Join",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "internal void Join(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionQueue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tconnection.state = Connection.State.InQueue;\r\n\tthis.queue.Add(connection);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQueueCycle",
      "HookName": "OnQueueCycle",
      "HookParameters": {
        "Int32": "availableSlots"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Cycle",
        "ReturnType": "void",
        "Arguments": {
          "availableSlots": "int"
        }
      },
      "CodeAfterInjection": "public void Cycle(int availableSlots)\r\n{\r\n\tif (Interface.CallHook(\"OnQueueCycle\", availableSlots) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.queue.Count == 0)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprinklerSplashed",
      "HookName": "OnSprinklerSplashed",
      "HookParameters": {
        "Sprinkler": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "Sprinkler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tif (this.DecayPerSplash > 0f)\r\n\t\t{\r\n\t\t\tbase.Hurt(this.DecayPerSplash);\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnSprinklerSplashed\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWaterBallSplash",
      "HookName": "CanWaterBallSplash",
      "HookParameters": {
        "ItemDefinition": "liquidDef",
        "Vector3": "position",
        "float": "radius",
        "int": "amount"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterBall",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "bool",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "radius": "float",
          "liquidDef": "ItemDefinition",
          "amount": "int"
        }
      },
      "CodeAfterInjection": "public static bool DoSplash(Vector3 position, float radius, global::ItemDefinition liquidDef, int amount)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWaterBallSplash\", liquidDef, position, radius, amount);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::BaseEntity> list = Pool.GetList<global::BaseEntity>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanFireLiquidWeapon",
      "HookName": "CanFireLiquidWeapon",
      "HookParameters": {
        "BasePlayer": "player",
        "LiquidWeapon": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CanFire",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanFire(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanFireLiquidWeapon\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.RequiresPumping && this.pressure < this.PressureLossPerTick)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFired",
      "HookName": "OnLiquidWeaponFired",
      "HookParameters": {
        "LiquidWeapon": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartFiring",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tthis.StartCooldown(this.FireRate);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFired\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFiringStopped",
      "HookName": "OnLiquidWeaponFiringStopped",
      "HookParameters": {
        "LiquidWeapon": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StopFiring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFiringStopped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCapture",
      "HookName": "OnPhotoCapture",
      "HookParameters": {
        "PhotoEntity": "player",
        "Item": "player",
        "BasePlayer": "player",
        "Byte[]": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\titem2.Remove(0f);\r\n\t\tDebug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (Interface.CallHook(\"OnPhotoCapture\", photoEntity, item, player, array) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.inventory.GiveItem(item2, null, false))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCaptured",
      "HookName": "OnPhotoCaptured",
      "HookParameters": {
        "PhotoEntity": "player",
        "Item": "player",
        "BasePlayer": "player",
        "Byte[]": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\titem2.Remove(0f);\r\n\t\tDebug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (Interface.CallHook(\"OnPhotoCapture\", photoEntity, item, player, array) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.inventory.GiveItem(item2, null, false))\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [DoorKnocker]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "DoorKnocker": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "DoorKnocker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Knock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void Knock(global::BasePlayer player)\r\n{\r\n\tbase.ClientRPC<Vector3>(null, \"ClientKnock\", player.transform.position);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTreeMarkerHit",
      "HookName": "OnTreeMarkerHit",
      "HookParameters": {
        "TreeEntity": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "TreeEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DidHitMarker",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (this.xMarker == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnTreeMarkerHit\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (global::PrefabAttribute.server.Find<global::TreeMarkerData>(this.prefabID) != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkSubscriptionsGather",
      "HookName": "OnNetworkSubscriptionsGather",
      "HookParameters": {
        "NetworkVisibilityGrid": "this",
        "Group": "group",
        "List`1": "groups",
        "Int32": "radius"
      },
      "ReturnBehavior": 1,
      "TargetType": "NetworkVisibilityGrid",
      "Category": "Network",
      "MethodData": {
        "MethodName": "GetVisibleFrom",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group",
          "groups": "System.Collections.Generic.List`1<Network.Visibility.Group>",
          "radius": "int"
        }
      },
      "CodeAfterInjection": "private void GetVisibleFrom(Group group, System.Collections.Generic.List<Group> groups, int radius)\r\n{\r\n\tif (Interface.CallHook(\"OnNetworkSubscriptionsGather\", this, group, groups, radius) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::NetworkVisibilityGrid.<>c__DisplayClass34_0 <>c__DisplayClass34_;\r\n\t<>c__DisplayClass34_.groups = groups;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [VendingMachine]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "VendingMachine": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (!base.OccupiedCheck(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendSellOrders(msg.player);\r\n\tthis.PlayerOpenLoot(msg.player, this.customerPanel, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [NPCTalking]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "InvisibleVendingMachine": "vendingMachine",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::InvisibleVendingMachine vendingMachine = base.GetVendingMachine();\r\n\t\tif (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\treturn;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAward",
      "HookName": "OnAdventGiftAward",
      "HookParameters": {
        "AdventCalendar": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void AwardGift(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnAdventGiftAward\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = now.Day - this.startDay;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAwarded",
      "HookName": "OnAdventGiftAwarded",
      "HookParameters": {
        "AdventCalendar": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void AwardGift(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnAdventGiftAward\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSystem.DateTime now = System.DateTime.Now;\r\n\tint num = now.Day - this.startDay;\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeAwardedAdventGift",
      "HookName": "CanBeAwardedAdventGift",
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "WasAwardedTodaysGift",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool WasAwardedTodaysGift(global::BasePlayer player)\r\n{\r\n\tobject OxideGen_2 = Interface.CallHook(\"CanBeAwardedAdventGift\", this, player);\r\n\tif (OxideGen_2 is bool)\r\n\t{\r\n\t\treturn !(bool)OxideGen_2;\r\n\t}\r\n\tif (!global::AdventCalendar.playerRewardHistory.ContainsKey(player.userID))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPainted",
      "HookName": "OnItemPainted",
      "HookParameters": {
        "PaintedItemStorageEntity": "this",
        "Item": "enumerator",
        "BasePlayer": "player",
        "Byte[]": "enumerator"
      },
      "ReturnBehavior": 0,
      "TargetType": "PaintedItemStorageEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Server_UpdateImage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\titem.LoseCondition(0.25f);\r\n\t\t}\r\n\t\tthis.lastEditedBy = msg.player.userID;\r\n\t}\r\n\tInterface.CallHook(\"OnItemPainted\", this, item, msg.player, array);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrainCarUncouple",
      "HookName": "OnTrainCarUncouple",
      "HookParameters": {
        "TrainCar": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsUncouple",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (Vector3.SqrMagnitude(base.transform.position - player.transform.position) > 200f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrainCarUncouple\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool front = msg.read.Bit();\r\n\tthis.coupling.Uncouple(front);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanTrainCarCouple",
      "HookName": "CanTrainCarCouple",
      "HookParameters": {
        "TrainCoupling": "this",
        "TrainCar": "owner"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCoupling",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryCouple",
        "ReturnType": "bool",
        "Arguments": {
          "theirCoupling": "TrainCoupling",
          "reflect": "bool"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (this.IsCoupled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanTrainCarCouple\", this.owner, theirCoupling.owner);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (reflect && !theirCoupling.TryCouple(this, false))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSamSiteModeToggle",
      "HookName": "OnSamSiteModeToggle",
      "HookParameters": {
        "SamSite": "this",
        "BasePlayer": "player",
        "bool": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ToggleDefenderMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsInDefenderMode())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSamSiteModeToggle\", this, player, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(this.Flag_DefenderMode, flag, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayCreate",
      "HookName": "OnSprayCreate",
      "HookParameters": {
        "SprayCan": "this",
        "Vector3": "vector",
        "Quaternion": "vector"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CreateSpray",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\r\n\t{\r\n\t\tDebug.Log(string.Format(\"SprayCan.ChangeItemSkin player does not have item :{0}:\", num));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayCreate\", this, vector, quaternion) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong skinID = global::ItemDefinition.FindSkin(this.SprayDecalItem.itemid, num);\r\n\tglobal::BaseEntity expr_160 = global::GameManager.server.CreateEntity(this.SprayDecalEntityRef.resourcePath, vector, quaternion, true);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLockerSwap",
      "HookName": "OnLockerSwap",
      "HookParameters": {
        "Locker": "this",
        "int": "num",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "Locker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_Equip",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= 3)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLockerSwap\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEquipping())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayRemove",
      "HookName": "OnSprayRemove",
      "HookParameters": {
        "SprayCanSpray": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCanSpray",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Server_RequestWaterClear",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (!this.Menu_WaterClear_ShowIf(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayRemove\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "SplashThresholdField [SprayCanSpray]",
      "HookName": "SplashThresholdField [SprayCanSpray]",
      "ReturnBehavior": 0,
      "TargetType": "SprayCanSpray",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "WantsSplash",
        "ReturnType": "bool",
        "Arguments": {
          "splashType": "ItemDefinition",
          "amount": "int"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnHelicopterAttacked [BaseHelicopter]",
      "HookName": "OnHelicopterAttacked",
      "HookParameters": {
        "BaseHelicopter": "this",
        "HitInfo": "info"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseHelicopter",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void Hurt(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnComposterUpdate",
      "HookName": "OnComposterUpdate",
      "HookParameters": {
        "Composter": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Composter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateComposting",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateComposting()\r\n{\r\n\tif (Interface.CallHook(\"OnComposterUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < base.inventory.capacity; i++)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsCount",
      "HookName": "OnInventoryItemsCount",
      "HookParameters": {
        "PlayerInventory": "this",
        "Int32": "itemid"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmount",
        "ReturnType": "int",
        "Arguments": {
          "itemid": "int"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (itemid == 0)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsCount\", this, itemid);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsFind",
      "HookName": "OnInventoryItemsFind",
      "HookParameters": {
        "PlayerInventory": "this",
        "Int32": "id"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindItemIDs",
        "ReturnType": "System.Collections.Generic.List`1<Item>",
        "Arguments": {
          "id": "int"
        }
      },
      "CodeAfterInjection": "public System.Collections.Generic.List<global::Item> FindItemIDs(int id)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsFind\", this, id);\r\n\tif (returnvar is System.Collections.Generic.List<global::Item>)\r\n\t{\r\n\t\treturn (System.Collections.Generic.List<global::Item>)returnvar;\r\n\t}\r\n\tSystem.Collections.Generic.List<global::Item> list = new System.Collections.Generic.List<global::Item>();\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoFind",
      "HookName": "OnInventoryAmmoFind",
      "HookParameters": {
        "PlayerInventory": "this",
        "List`1": "list",
        "AmmoTypes": "ammoType"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindAmmo",
        "ReturnType": "void",
        "Arguments": {
          "list": "System.Collections.Generic.List`1<Item>",
          "ammoType": "Rust.AmmoTypes"
        }
      },
      "CodeAfterInjection": "public void FindAmmo(System.Collections.Generic.List<global::Item> list, AmmoTypes ammoType)\r\n{\r\n\tif (Interface.CallHook(\"OnInventoryAmmoFind\", this, list, ammoType) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.containerMain != null)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDroppedItemCombined",
      "HookName": "OnDroppedItemCombined",
      "HookParameters": {
        "DroppedItem": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "OnDroppedOn",
        "ReturnType": "void",
        "Arguments": {
          "di": "DroppedItem"
        }
      },
      "CodeAfterInjection": "...\r\n\t}\r\n\tif (di.item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanCombineDroppedItem\", this, di) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != this.item.info)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRandomItemAward",
      "HookName": "OnRandomItemAward",
      "ReturnBehavior": 0,
      "TargetType": "RandomItemDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "TryAward",
        "ReturnType": "bool",
        "Arguments": {
          "itemChance": "RandomItemDispenser/RandomItemChance",
          "forPlayer": "BasePlayer",
          "distributorPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "private bool TryAward(global::RandomItemDispenser.RandomItemChance itemChance, global::BasePlayer forPlayer, Vector3 distributorPosition)\r\n{\r\n\tif (Interface.CallHook(\"OnRandomItemAward\", this, itemChance, forPlayer, distributorPosition) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\tif (itemChance.Chance >= num)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoteIdentifierUpdate",
      "HookName": "OnRemoteIdentifierUpdate",
      "HookParameters": {
        "PoweredRemoteControlEntity": "this",
        "string": "newID"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateIdentifier",
        "ReturnType": "void",
        "Arguments": {
          "newID": "string",
          "clientSend": "bool"
        }
      },
      "CodeAfterInjection": "public void UpdateIdentifier(string newID, bool clientSend = false)\r\n{\r\n\tif (Interface.CallHook(\"OnRemoteIdentifierUpdate\", this, newID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring arg_16_0 = this.rcIdentifier;\r\n\tif (base.isServer)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStart",
      "HookName": "OnOvenStart",
      "HookParameters": {
        "BaseOven": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void StartCooking()\r\n{\r\n\tif (Interface.CallHook(\"OnOvenStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.FindBurnable() == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStarted",
      "HookName": "OnOvenStarted",
      "HookParameters": {
        "BaseOven": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void StartCooking()\r\n{\r\n\tif (Interface.CallHook(\"OnOvenStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.FindBurnable() == null && !this.CanRunWithNoFuel)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerBanned [EAC]",
      "HookName": "OnPlayerBanned",
      "HookParameters": {
        "Connection": "timeWarning",
        "string": "ToString()"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t2,\r\n\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username + \" (banned by anticheat)\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tInterface.CallHook(\"OnPlayerBanned\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tConVar.Entity.DeleteBy(connection.userid);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked [EAC]",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "Connection": "timeWarning",
        "string": "ToString()"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t2,\r\n\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username + \" (banned by anticheat)\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tInterface.CallHook(\"OnPlayerBanned\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tConVar.Entity.DeleteBy(connection.userid);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenTemperature",
      "HookName": "OnOvenTemperature",
      "HookParameters": {
        "BaseOven": "this",
        "Int32": "slot"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetTemperature",
        "ReturnType": "float",
        "Arguments": {
          "slot": "int"
        }
      },
      "CodeAfterInjection": "public float GetTemperature(int slot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnOvenTemperature\", this, slot);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\tif (!base.HasFlag(global::BaseEntity.Flags.On))\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFeedbackReported [patch]",
      "HookName": "OnFeedbackReported",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "OnFeedbackReport",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t\tSubject = text\r\n\t\t};\r\n\t\tfeedback.AppInfo.Image = image;\r\n\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, this.userID, ConVar.Server.reportsServerEndpointKey, feedback);\r\n\t}\r\n\tInterface.CallHook(\"OnFeedbackReported\", this, text, text2, reportType);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUse",
      "HookName": "OnPortalUse",
      "HookParameters": {
        "BasePlayer": "player",
        "BasePortal": "this"
      },
      "ReturnBehavior": 4,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void UsePortal(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPortalUse\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.LinkPortal();\r\n\tif (this.targetPortal != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUsed",
      "HookName": "OnPortalUsed",
      "HookParameters": {
        "BasePlayer": "player",
        "BasePortal": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void UsePortal(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPortalUse\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.LinkPortal();\r\n\tif (this.targetPortal != null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDespawn",
      "HookName": "OnItemDespawn",
      "HookParameters": {
        "DroppedItem": "this"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "IdleDestroy",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void IdleDestroy()\r\n{\r\n\tInterface.CallHook(\"OnItemDespawn\", this.item);\r\n\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, this.item, (int)this.DropReason, this.DroppedBy);\r\n\tbase.DestroyItem();\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [ModularCarCodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "BasePlayer": "player",
        "ModularCarCodeLock": "this",
        "string": "codeEntered"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarCodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryOpenWithCode",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "codeEntered": "string"
        }
      },
      "CodeAfterInjection": "public bool TryOpenWithCode(global::BasePlayer player, string codeEntered)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlock\", player, this, codeEntered);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.CodeEntryBlocked(player))\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockRequest",
      "HookName": "OnVehicleLockRequest",
      "HookParameters": {
        "ModularCarGarage": "this",
        "BasePlayer": "player",
        "string": "player"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_RequestAddLock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256);\r\n\tif (Interface.CallHook(\"OnVehicleLockRequest\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemAmount itemAmount = this.lockResourceCost;\r\n\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && this.carOccupant.CarLock.TryAddALock(text, player.userID))\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [IndustrialCrafter]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "IndustrialCrafter",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (this.NeedsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConveyorFiltersChange",
      "HookName": "OnConveyorFiltersChange",
      "HookParameters": {
        "IndustrialConveyor": "this",
        "BasePlayer": "player",
        "ItemFilterList": "itemFilterList"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RPC_ChangeFilters",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\tProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = ProtoBuf.IndustrialConveyor.ItemFilterList.Deserialize(msg.read);\r\n\tif (itemFilterList.filters == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnConveyorFiltersChange\", this, msg.player, itemFilterList) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = Mathf.Min(itemFilterList.filters.Count, 24);\r\n\tint num2 = 0;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [IndustrialConveyor]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "IndustrialConveyor": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(2uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SvSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [IndustrialConveyor]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "IndustrialConveyor": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(2uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SvSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft [IndustrialCrafter]",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "IndustrialCrafter": "this",
        "ItemBlueprint": "i"
      },
      "ReturnBehavior": 1,
      "TargetType": "IndustrialCrafter",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RunJob",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t{\r\n\t\tglobal::Item targetBlueprint = this.GetTargetBlueprint(i);\r\n\t\tif (targetBlueprint != null && !(this.GetWorkbench() == null) && this.GetWorkbench().Workbenchlevel >= targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)\r\n\t\t{\r\n\t\t\tglobal::ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\r\n\t\t\tif (Interface.CallHook(\"OnItemCraft\", this, blueprint) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbool flag = true;\r\n\t\t\tforeach (global::ItemAmount current in blueprint.ingredients)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleHornPressed",
      "HookName": "OnVehicleHornPressed",
      "HookParameters": {
        "VehicleModuleSeating": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleSeating",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "...\r\n\t\t{\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, flag, false, true);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnVehicleHornPressed\", this, player);\r\n\t\t\tthis.hornPlayer = player;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanExplosiveStick",
      "HookName": "CanExplosiveStick",
      "HookParameters": {
        "TimedExplosive": "this",
        "BaseEntity": "entity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TimedExplosive",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CanStickTo",
        "ReturnType": "bool",
        "Arguments": {
          "entity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool CanStickTo(global::BaseEntity entity)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanExplosiveStick\", this, entity);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::DecorDeployable decorDeployable;\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "PlayerInventory": "inventory",
        "Chainsaw": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "Chainsaw",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tglobal::Item item = ownerPlayer.inventory.containerMain.FindItemsByItemName(this.fuelType.shortname);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "PlayerInventory": "inventory",
        "FlameThrower": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameThrower",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tglobal::Item item = ownerPlayer.inventory.containerMain.FindItemsByItemName(this.fuelType.shortname);\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSeeStash",
      "HookName": "CanSeeStash",
      "HookParameters": {
        "BasePlayer": "player",
        "StashContainer": "this"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashExposed",
      "HookName": "OnStashExposed",
      "HookParameters": {
        "StashContainer": "this",
        "BasePlayer": "player"
      },
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnStashExposed [patch]",
      "HookName": "OnStashExposed [patch]",
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_WantsUnhide",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "...\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (this.PlayerInRange(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"CanSeeStash\", player, this) != null)\r\n\t\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerCommand",
      "HookName": "IOnServerCommand",
      "HookParameters": {
        "Arg": "arg"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Internal",
        "ReturnType": "bool",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "...\r\n{\r\n\tif (arg.Invalid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"IOnServerCommand\", arg);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!arg.HasPermission())\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdPrefix [patch]",
      "HookName": "SingleCharCmdPrefix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "IOnRunCommandLine",
      "HookName": "IOnRunCommandLine",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateValuesFromCommandLine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void UpdateValuesFromCommandLine()\r\n{\r\n\tif (Interface.CallHook(\"IOnRunCommandLine\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (KeyValuePair<string, string> current in Facepunch.CommandLine.GetSwitches())\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdSuffix [patch]",
      "HookName": "SingleCharCmdSuffix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [web]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "IPAddress": "ClientIpAddress"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_0",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__0(IWebSocketConnection socket)\r\n{\r\n\tListener.<>c__DisplayClass10_1 <>c__DisplayClass10_ = new Listener.<>c__DisplayClass10_1();\r\n\t<>c__DisplayClass10_.CS$<>8__locals1 = this;\r\n\t<>c__DisplayClass10_.socket = socket;\r\n\tif (Interface.CallHook(\"OnRconConnection\", socket.ConnectionInfo.ClientIpAddress) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (<>c__DisplayClass10_.socket.ConnectionInfo.Path != this.requiredPath)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [web, patch]",
      "HookName": "OnRconConnection [web, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_0",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__0(IWebSocketConnection socket)\r\n{\r\n\tListener.<>c__DisplayClass10_1 <>c__DisplayClass10_ = new Listener.<>c__DisplayClass10_1();\r\n\t<>c__DisplayClass10_.CS$<>8__locals1 = this;\r\n\t<>c__DisplayClass10_.socket = socket;\r\n\tif (Interface.CallHook(\"OnRconConnection\", socket.ConnectionInfo.ClientIpAddress) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (<>c__DisplayClass10_.socket.ConnectionInfo.Path != this.requiredPath)\r\n\t{\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnRconMessage",
      "HookName": "IOnRconMessage",
      "HookParameters": {
        "<>c__DisplayClass10_1": "this",
        "string": "s"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass10_1",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__3",
        "ReturnType": "void",
        "Arguments": {
          "s": "string"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__3(string s)\r\n{\r\n\tif (Interface.CallHook(\"IOnRconMessage\", this.socket.ConnectionInfo.ClientIpAddress, s) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tAction<IPAddress, int, string> expr_2F = this.CS$<>8__locals1.<>4__this.OnMessage;\r\n\tif (expr_2F == null)\r\n...\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnected",
      "HookName": "OnClientDisconnected",
      "HookParameters": {
        "Connection": "cn",
        "string": "strReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "Network.Server",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "cn": "Network.Connection"
        }
      },
      "CodeAfterInjection": "...\r\n\tcn.active = false;\r\n\tif (this.callbackHandler != null)\r\n\t{\r\n\t\tthis.callbackHandler.OnDisconnected(strReason, cn);\r\n\t}\r\n\tInterface.CallHook(\"OnClientDisconnected\", cn, strReason);\r\n\tthis.RemoveConnection(cn);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateSubscriptions",
        "ReturnType": "bool",
        "Arguments": {
          "removeLimit": "int",
          "addLimit": "int"
        }
      },
      "CodeAfterInjection": "...\r\n\t\tList<Group> list2 = Pool.GetList<Group>();\r\n\t\tList<Group> list3 = Pool.GetList<Group>();\r\n\t\tthis.sv.visibility.GetVisibleFromFar(this.group, list3);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, list3);\r\n\t\tthis.subscriber.subscribed.Compare(list3, list, list2, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, list2) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list2.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list2[i];\r\n\t\t\t\tif (removeLimit > 0)\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate [2]",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateHighPrioritySubscriptions",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "...\r\n\t\tList<Group> list = Pool.GetList<Group>();\r\n\t\tList<Group> list2 = Pool.GetList<Group>();\r\n\t\tthis.sv.visibility.GetVisibleFromNear(this.group, list2);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, list2);\r\n\t\tthis.subscriber.subscribed.Compare(list2, list, null, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, null) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list[i];\r\n\t\t\t\tthis.subscriber.Subscribe(group);\r\n...\r\n"
    },
    {
      "Type": 1,
      "Name": "NoPragmaColumnExists [patch]",
      "HookName": "NoPragmaColumnExists",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Sqlite.Database",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ColumnExists",
        "ReturnType": "bool",
        "Arguments": {
          "tableName": "string",
          "columnName": "string"
        }
      }
    },
    {
      "Type": 1,
      "Name": "LogSqliteVersion [patch]",
      "HookName": "LogSqliteVersion",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Sqlite.Database",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Open",
        "ReturnType": "void",
        "Arguments": {
          "path": "string",
          "fastMode": "bool"
        }
      }
    }
  ]
}